# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from ctypes import *                                                            
lib1 = cdll.LoadLibrary('../lib/libNFsim.so')                                        
lib2 = cdll.LoadLibrary('../lib/libnfsim_c.so')





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_pymcell')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_pymcell')
    _pymcell = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pymcell', [dirname(__file__)])
        except ImportError:
            import _pymcell
            return _pymcell
        if fp is not None:
            try:
                _mod = imp.load_module('_pymcell', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pymcell = swig_import_helper()
    del swig_import_helper
else:
    import _pymcell
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

"""pyMCell helper functions.

Currently, this contains a mix of the original pyMCell functions and classes
and a set of more refined intuitive functions and classes. Future versions will
provide a cleaner separation between these two with the aim of eventually
deprecating or removing the original ones.

"""

import pymcell as m
from typing import List, Dict, Iterable, Tuple, Any
import logging
from enum import Enum
# import uuid
import random


class Orient(Enum):
    up = 1
    down = 2
    mix = 3


class SC(Enum):
    reflect = 1
    transp = 2
    absorb = 3
    conc_clamp = 3


class MolType(Enum):
    surface_mols = 1
    volume_mols = 2
    all_mols = 3


def single_true(iterable):
    i = iter(iterable)
    return any(i) and not any(i)


class MeshObj:
    """ An entire polygon object and its associated surface regions. """
    def __init__(
            self,
            name: str,
            vert_list: List[Tuple[float, float, float]],
            face_list: List[Tuple[int, int, int]],
            translation: Tuple[float, float, float] = None) -> None:
        self.name = name
        self.vert_list = vert_list
        self.face_list = face_list
        self.regions = []  # type: List[SurfaceRegion]
        self.translation = translation
        logging.info("Creating mesh object '%s'" % name)

    def __str__(self):
        return self.name


class Species:
    """ A type of molecule.

    Surface molecules have names, diffusion constants , and can either be a
    surface molecule (embedded in a membrane) or a volume molecule (e.g. free
    in the cytocol). The units for the diffusion constant is cm2/s.  An
    instance of Species is still a *type* of molecule, not an individual
    molecule. For example, an instance of Species could be the ACh Species, but
    it would not be an individual ACh molecule.
    """
    def __init__(
            self,
            name: str,
            diffusion_constant: float,
            surface: bool = False) -> None:
        self.name = name
        self.diffusion_constant = diffusion_constant
        self.surface = surface
        vol_surf = "surface" if surface else "volume"
        logging.info("Creating %s species '%s'" % (vol_surf, name))

    def up(self):
        return OrientedSpecies(self, Orient.up)

    def down(self):
        return OrientedSpecies(self, Orient.down)

    def mix(self):
        return OrientedSpecies(self, Orient.mix)

    def __str__(self):
        return self.name


class OrientedSpecies:
    """ A type of molecule with an orientation.

    This is like a normal Species object, but it also contains information
    about its relative orientation (up, down, or mixed) with respect to a
    surface membrane.
    """
    def __init__(
            self,
            spec: Species,
            orient: Orient) -> None:
        self.spec = spec
        odict_str = {Orient.up: "'", Orient.down: ",", Orient.mix: ";"}
        odict_num = {Orient.up: 1, Orient.down: -1, Orient.mix: 0}
        self.orient = orient
        self.orient_num = odict_num[orient]
        self.orient_str = odict_str[orient]
        self.name = self.spec.name + self.orient_str

    def __str__(self):
        return self.name


class Reaction:
    """ A reaction involving one or more molecules.

    ex: vm1 -> vm2 + vm3 [1e3]
    - Can be unimolecular or bimolecular.
    - Involves surface and/or volume molecules.
    - If a single surface molecule is involved, then all species in the
      reaction must be OrientedSpecies.
    """
    def __init__(
            self,
            reactants: List[Any],  # List of Species or OrientedSpecies
            products: List[Any],  # List of Species or OrientedSpecies
            rate_constant: float,
            bkwd_rate_constant=None,
            name=None) -> None:
        self.reactants = reactants
        self.products = products
        self.rate_constant = rate_constant
        self.bkwd_rate_constant = bkwd_rate_constant
        self.name = name
# These variable names are terrible...
# reactants_so = all(isinstance(r, m.OrientedSpecies) for r in reactants)
# products_so = all(isinstance(p, m.OrientedSpecies) for p in products)
# reactants_s = all(isinstance(r, m.Species) for r in reactants)
# products_s = all(isinstance(p, m.Species) for p in products)
# if (reactants_so and (products_so or not products)) or (reactants_s and products_s):
#     # make sure either everything is oriented (aside from possible NULL
#     # product) or nothing is.
#     pass
# else:
#     logging.info(
#         "Mixing oriented with non oriented species in reaction")
        try:
            reactant_names = [r.name for r in reactants]
            reactants_str = " + ".join(reactant_names)
        except TypeError:
# must be unimolecular
            reactants_str = reactants.name
        try:
            if products:
                product_names = [p.name for p in products]
                products_str = " + ".join(product_names)
            else:
                products_str = "NULL"
        except TypeError:
            products_str = products.name

        arrow = "<->" if bkwd_rate_constant else "->"

        self.print_friendly_repr = ""
        if bkwd_rate_constant:
            self.print_friendly_repr = "%s <-> %s [%.2E, %.2E]" % (reactants_str, products_str, rate_constant, bkwd_rate_constant)
        else:
            self.print_friendly_repr = "%s -> %s [%.2E]" % (reactants_str, products_str, rate_constant)
        logging.info("Creating reaction %s" % self.print_friendly_repr)

    def __str__(self):
        return self.name


class SurfaceRegion:
    """ Subsets of a surface.

    Examples of uses: molecules can be released on to these and surface classes
    can be assigned to them.
    """
    def __init__(self,
                 mesh_obj: MeshObj,
                 reg_name: str,
                 surf_reg_face_list: List) -> None:
        self.reg_name = reg_name
        self.full_reg_name = "%s[%s]" % (mesh_obj.name, reg_name)
        self.surf_reg_face_list = surf_reg_face_list
# Relationship is symmetrical. Every region knows its object. Object
# knows its regions.
        self.mesh_obj = mesh_obj
        mesh_obj.regions.append(self)
        logging.info("Creating region '%s'" % self.reg_name)

    def __str__(self):
        return self.reg_name


class ListRelease:
    """ A release of molecules specified as a series of XYZ coordinates. """
    def __init__(
            self,
            spec,
            pos_list: Iterable[Tuple[float, float, float]])-> None:
        self.spec = spec
        self.pos_list = pos_list
        logging.info("Creating list release")


class ObjectRelease:
    """ An entire polygon object and its associated surface regions. """
    def __init__(
            self,
            spec,
            number: int = None,
            conc: float = None,
            density: float = None,
            mesh_obj: MeshObj = None,
            region: SurfaceRegion = None) -> None:
        if not single_true((number, conc, density)):
            raise Exception(
                "Multiple release methods (e.g. number and conc) specified")
        self.spec = spec
        self.number = number
        self.conc = conc
        self.density = density
        self.region = region
        self.what_in_where = ""
        if self.region:
            self.mesh_obj = self.region.mesh_obj
            self.what_in_where = "{} in/on {}".format(self.spec.name, self.region.reg_name)
        else:
            self.mesh_obj = mesh_obj
            self.what_in_where = "{} in/on {}".format(self.spec.name, self.mesh_obj.name)
        logging.info("Creating release of {}".format(self.what_in_where))


class Vector3:
    """ Just a generic 3d vector to be used for positions and whatnot. """
    def __init__(self, x: float = 0.0, y: float = 0.0, z: float = 0.0) -> None:
        self.x = x
        self.y = y
        self.z = z

    def __str__(self):
        return "({}, {}, {})".format(self.x, self.y, self.z)


class SurfaceClass:
    """ A SurfaceClass describes how species interact with various surfaces.

    ex: Species x are absorbed when they hit the front of a surface.
    """
    def __init__(
            self, sc_type: SC, species, name=None) -> None:
        self.sc_type = sc_type
        self.species = species
        sc_dict = {SC.transp: "transparent", SC.reflect: "reflective",  SC.absorb: "absorptive" }
        if name:
            self.name = name
        else:
            self.name = "{}_{}".format(sc_dict[sc_type], species.name)
        logging.info(
            "Creating surface class that is {} to {}".format(sc_dict[sc_type], species.name))

    def __str__(self):
        return self.name


class MCellSim:
    """ The main class required to run a pyMCell simulation. """
    def __init__(self, seed: int) -> None:
        self._world = m.mcell_create()
        self._started = False
# the value for _species & _surface_classes is a swig wrapped sym_entry
        self._species = {}  # type: Dict[str, Any]
        self._surface_classes = {}  # type: Dict[str, Any]
# the value for _mesh_objects is a swig wrapped "object"
        self._mesh_objects = {}  # type: Dict[str, Any]
# the value for _mesh_objects is a swig wrapped "region"
        self._regions = {}  # type: Dict[str, Any]
        self._releases = {}  # type: Dict[str, Any]
        self._counts = {}  # type: Dict[str, Any]
        self._iterations = 0
        self._current_iteration = 0
        self._finished = False
        self._output_freq = 10
        self._seed = seed
        m.mcell_set_seed(self._world, seed)
# m.mcell_silence_notifications(self._world)
        m.mcell_init_state(self._world)
# This is the top level instance object. We just call it "Scene" here
# to be consistent with the MDL output from Blender.
        self.scene_name = "Scene"
        self._scene = m.create_instance_object(self._world, self.scene_name)

# this is different than _species. instead of swig wrapped sym_entry,
# this contains Species objects
        self.species = {}

# These allow you to have surface properties affect all molecules.
        self._all_mol_sym = m.mcell_get_all_mol_sym(self._world)
        self._species['ALL_MOLECULES'] = self._all_mol_sym
        self._all_volume_mol_sym = m.mcell_get_all_volume_mol_sym(self._world)
        self._species['ALL_VOLUME_MOLECULES'] = self._all_volume_mol_sym
        self._all_surface_mol_sym = m.mcell_get_all_mol_sym(self._world)
        self._species['ALL_SURFACE_MOLECULES'] = self._all_surface_mol_sym

    def __str__(self):
        return self.scene_name

    def __del__(self):
        self.end_sim()

    def silence_warnings(self):
        m.mcell_silence_warnings(self._world)

    def silence_notifications(self):
        m.mcell_silence_notifications(self._world)

    def enable_logging(self):
        logging.basicConfig(format='%(message)s', level=logging.DEBUG)

    def set_output_freq(self, output_freq: int) -> None:
        """ The interval of iterations to create reaction data output. 

        For example, if you set this to 10, reaction data would be created at
        every 10th iteration.
        """
        self._output_freq = output_freq

    def set_time_step(self, time_step: float) -> None:
        """ Set time step in seconds. """
        m.mcell_set_time_step(self._world, time_step)

    def set_iterations(self, iterations: int) -> None:
        """ Set number of iterations """
        m.mcell_set_iterations(self._world, iterations)
        self._iterations = iterations

# def set_seed(self, seed):
#     self._seed = seed
#     m.mcell_set_seed(self._world, seed)

    def add_single_species(self, spec):
        if spec.name not in self._species:
            spec_sym = m.create_species(
                self._world, spec.name, spec.diffusion_constant, spec.surface)
            self._species[spec.name] = spec_sym
            self.species[spec.name] = spec
            logging.info("Add species '%s' to simulation" % spec.name)

    def add_species(self, spec):
        if isinstance(spec, m.Species):
            self.add_single_species(spec)
        else:
            for s in spec:
                self.add_single_species(s)

    def add_reaction(self, rxn: Reaction) -> None:
        """ Add a Reaction object to the simulation. """
        r_spec_list = None
        p_spec_list = None
# Figure out if it's an iterable of reactants or a single reactant
        try:
            for r in rxn.reactants:
                if isinstance(r, m.OrientedSpecies):
                    r_sym = self._species[r.spec.name]
                    r_spec_list = m.mcell_add_to_species_list(
                        r_sym, True, r.orient_num, r_spec_list)
                else:
                    r_sym = self._species[r.name]
                    r_spec_list = m.mcell_add_to_species_list(
                        r_sym, False, 0, r_spec_list)
        except TypeError:
            r = rxn.reactants
            if isinstance(r, m.OrientedSpecies):
                r_sym = self._species[r.spec.name]
                r_spec_list = m.mcell_add_to_species_list(
                    r_sym, True, r.orient_num, r_spec_list)
            else:
                r_sym = self._species[r.name]
                r_spec_list = m.mcell_add_to_species_list(
                    r_sym, False, 0, r_spec_list)
        try:
            for p in rxn.products:
                if isinstance(r, m.OrientedSpecies):
                    p_sym = self._species[p.spec.name]
                    p_spec_list = m.mcell_add_to_species_list(
                        p_sym, True, p.orient_num, p_spec_list)
                else:
                    p_sym = self._species[p.name]
                    p_spec_list = m.mcell_add_to_species_list(
                        p_sym, False, 0, p_spec_list)
        except TypeError:
            p = rxn.products
            if isinstance(r, m.OrientedSpecies):
                p_sym = self._species[p.spec.name]
                p_spec_list = m.mcell_add_to_species_list(
                    p_sym, True, p.orient_num, p_spec_list)
            else:
                p_sym = self._species[p.name]
                p_spec_list = m.mcell_add_to_species_list(
                    p_sym, False, 0, p_spec_list)
        logging.info("Add reaction '%s' to simulation" % rxn.print_friendly_repr)
        m.create_reaction(
            self._world,
            r_spec_list,
            p_spec_list,
            rxn.rate_constant,
            rxn.bkwd_rate_constant,
            name=rxn.name)

    def add_geometry(self, mesh_obj: MeshObj) -> None:
        """ Add a mesh object to the simulation. """
        mesh = m.create_polygon_object(
            self._world,
            mesh_obj.vert_list,
            mesh_obj.face_list,
            self._scene,
            mesh_obj.name,
            mesh_obj.translation)
        if mesh_obj.name not in self._mesh_objects:
            self._mesh_objects[mesh_obj.name] = mesh
        for reg in mesh_obj.regions:
            region_swig_obj = m.create_surface_region(
                self._world, mesh, reg.surf_reg_face_list, reg.reg_name)
            full_reg_name = "%s[%s]" % (mesh_obj.name, reg.reg_name)
            if reg.reg_name not in self._regions:
                self._regions[full_reg_name] = region_swig_obj
        logging.info("Add geometry '%s' to simulation" % mesh_obj.name)

    def add_viz(self, species: Iterable[Species]) -> None:
        """ Set all the species in an Iterable to be visualized. """
        viz_list = None
        for spec in species:
            viz_list = m.mcell_add_to_species_list(
                self._species[spec.name], False, 0, viz_list)
            logging.info("Output '%s' for viz data." % spec.name)
        m.mcell_create_viz_output(
            self._world, "./viz_data/seed_%04i/Scene" % self._seed, viz_list,
            0, self._iterations, 1)

    def release(self, relobj):
        """ Release molecules in/on an object or as a ListRelease. """
        if isinstance(relobj, ObjectRelease):
            self.release_into_mesh_obj(relobj)
            logging.info("Add release of '%s' to simulation" % relobj.what_in_where)
        elif isinstance(relobj, ListRelease):
            self.release_as_list(relobj.spec, relobj.pos_list)
            logging.info("Add list release to simulation")
        else:
            raise ValueError("Invalid release site type")

    def release_as_list(self, spec, pos_list):
        length_pos_list = len(pos_list)
        try:
            spec_list = []
            surf_flags = []
            orient = []
            for s in spec:
                if isinstance(s, OrientedSpecies):
                    spec_list.append(self._species[s.spec.name])
                    surf_flags.append(True)
                    orient.append(s.orient_num)
                else:
                    spec_list.append(self._species[s.spec.name])
                    surf_flags.append(False)
                    orient.append(0)

        except TypeError:
            if isinstance(spec, OrientedSpecies):
                spec_sym = self._species[spec.spec.name]
                spec_list = [spec_sym] * length_pos_list
                surf_flags = [True] * length_pos_list
                orient = [spec.orient_num] * length_pos_list
            else:
                spec_sym = self._species[spec.name]
                surf_flags = None
                orient = None
            spec_list = [spec_sym] * length_pos_list
# XXX: HACK. This is definitely not guaranteed to be unique, but I
# can't UUID to work for some reason
        rel_name = "rel_{}".format(random.randint(1,1000))
# rel_name = "rel_{}".format(uuid.uuid1())
        x_pos = []
        y_pos = []
        z_pos = []
        for pos in pos_list:
            x_pos.append(pos[0])
            y_pos.append(pos[1])
            z_pos.append(pos[2])
        (rel_obj, return_status) = m.create_list_release_site(
                self._world, self._scene, spec_list, x_pos, y_pos, z_pos,
                rel_name, surf_flags=surf_flags, orientations=orient)
        if rel_name not in self._releases:
            self._releases[rel_name] = (rel_obj, return_status)

    def release_into_mesh_obj(self, relobj) -> None:
        """ Release the specified amount of species into an object. """

        mesh_obj = relobj.mesh_obj
        species = relobj.spec
        region = relobj.region

        if isinstance(species, m.OrientedSpecies):
            orient = species.orient_num
            species = species.spec
        else:
            orient = None
        if species.surface and orient is None:
            logging.info(
                "Error: must specify orientation when releasing surface "
                "molecule")
        if region:
            rel_name = "%s_%s_%s_rel" % (
                    species.name, mesh_obj.name, region.reg_name)
        else:
            rel_name = "%s_%s_rel" % (species.name, mesh_obj.name)

        mol_sym = self._species[species.name]
        if orient:
            mol_list = m.mcell_add_to_species_list(mol_sym, True, orient, None)
        else:
            mol_list = m.mcell_add_to_species_list(mol_sym, False, 0, None)
        rel_object = m.object()
        if relobj.number:
            number_type = 0
            rel_amt = relobj.number
        elif relobj.conc:
            number_type = 1
            rel_amt = relobj.conc
        if region:
            reg_name = region.reg_name
        else:
            reg_name = "ALL"
        release_object = m.mcell_create_region_release(
            self._world, self._scene, self._mesh_objects[mesh_obj.name],
            rel_name, reg_name, mol_list, float(rel_amt),
            number_type, 1, None, rel_object)
        if rel_name not in self._releases:
            self._releases[rel_name] = release_object
        m.mcell_delete_species_list(mol_list)
# logging.info("Creating release site '%s'" % rel_name)

    def create_release_site(
            self, species: Species, count: int, shape: str,
            pos_vec3: Vector3 = None, diam_vec3=None) -> None:
        """ Create a spherical/cubic release site. """
        if pos_vec3 is None:
            pos_vec3 = m.Vector3()
        if diam_vec3 is None:
            diam_vec3 = m.Vector3()
        species_sym = self._species[species.name]
        rel_name = "%s_%s_rel" % (species.name, shape)
        if shape == "spherical":
            shape = m.SHAPE_SPHERICAL
        elif shape == "cubic":
            shape = m.SHAPE_CUBIC
        position, diameter, release_object = m.create_release_site(
            self._world, self._scene, pos_vec3, diam_vec3, shape,
            count, 0, species_sym, rel_name)
        if rel_name not in self._releases:
            self._releases[rel_name] = (position, diameter, release_object)

    def add_partitions(
            self, axis: str, start: float, stop: float, step: float) -> None:
        """ Add partitions to speed up the simulation. """
        if axis == "x":
            axis_num = 0
        elif axis == "y":
            axis_num = 1
        elif axis == "z":
            axis_num = 2
        m.create_partitions(self._world, axis_num, start, stop, step)

    def add_count(self, species: Species, mesh_obj: MeshObj = None,  reg: SurfaceRegion = None) -> None:
        """ Set a species (possibly in/on a surface) to be counted """
        species_sym = self._species[species.name]
        if mesh_obj:
            mesh = self._mesh_objects[mesh_obj.name]
            mesh_sym = m.mcell_get_obj_sym(mesh)
            count_str = "react_data/seed_%04d/%s_%s" % (
                    self._seed, species.name, mesh_obj.name)
            count_list, os, out_times, output = m.create_count(
                self._world, mesh_sym, species_sym, count_str, 1e-5)
        elif reg:
            reg_swig_obj = self._regions[reg.full_reg_name]
            reg_sym = m.mcell_get_reg_sym(reg_swig_obj)
            count_str = "react_data/seed_%04d/%s_%s_%s" % (
                    self._seed, species.name, reg.mesh_obj.name, reg.reg_name)
            count_list, os, out_times, output = m.create_count(
                self._world, reg_sym, species_sym, count_str, 1e-5)
        else:
            count_str = "react_data/seed_%04d/%s_WORLD" % (
                    self._seed, species.name)
            count_list, os, out_times, output = m.create_count(
                self._world, None, species_sym, count_str, 1e-5)
        self._counts[count_str] = (count_list, os, out_times, output)

    def _get_sc_type(self, sc_type):
        if sc_type == SC.reflect:
            sc_type = m.RFLCT
        elif sc_type == SC.transp:
            sc_type = m.TRANSP
        elif sc_type == SC.absorb:
            sc_type = m.SINK
        return sc_type

    def assign_surface_property_to_all_mols(self, sc_name, sc_type, region, moltype=MolType.all_mols):
        sc_type = self._get_sc_type(sc_type)

        if moltype == MolType.surface_mols:
            moltype = 'ALL_SURFACE_MOLECULES'
        elif moltype == MolType.volume_mols:
            moltype = 'ALL_VOLUME_MOLECULES'
        elif moltype == MolType.all_mols:
            moltype = 'ALL_MOLECULES'

        try:
            sc_sym = self._surface_classes[sc_name]
        except KeyError:
            sc_sym = m.create_surf_class(self._world, sc_name)
            self._surface_classes[sc_name] = sc_sym
            spec_sym = self._species[moltype]
# XXX: add support for orientation
            m.mcell_add_surf_class_properties(
                self._world, sc_type, sc_sym, spec_sym, 0)
        region_swig_obj = self._regions[region.full_reg_name]
        m.mcell_assign_surf_class_to_region(sc_sym, region_swig_obj)

    def assign_surf_class(
            self, sc: SurfaceClass, region: SurfaceRegion) -> None:
        """ Assign a surface class to a region. """

        sc_type = self._get_sc_type(sc.sc_type)

        if isinstance(sc.species, m.OrientedSpecies):
            orient = sc.species.orient_num
            spec_name = sc.species.spec.name
        else:
            orient = 0
            spec_name = sc.species.name
        try:
            sc_sym = self._surface_classes[sc.name]
        except KeyError:
            sc_sym = m.create_surf_class(self._world, sc.name)
            self._surface_classes[sc.name] = sc_sym
            spec_sym = self._species[spec_name]
            m.mcell_add_surf_class_properties(
                self._world, sc_type, sc_sym, spec_sym, orient)
        region_swig_obj = self._regions[region.full_reg_name]
        m.mcell_assign_surf_class_to_region(sc_sym, region_swig_obj)

    def get_species_count(self, species: Species, mesh_obj: MeshObj) -> int:
        """ Get the current count of a molecule species. """
        return m.mcell_get_count(
            species.name, "Scene.%s,ALL" % mesh_obj.name, self._world)

    def modify_rate_constant(
            self, rxn: Reaction, new_rate_constant: float) -> None:
        """ Modify the rate constant of the specified reaction. """
        if not rxn.name:
            print("You can only change a named reaction.")
        else:
            m.mcell_modify_rate_constant(
                self._world, rxn.name, new_rate_constant)

    def run_iteration(self) -> None:
        """ Run a single iteration. """
        if self._finished:
            print("The simulation is done running")
            return

        if not self._started:
            m.mcell_init_simulation(self._world)
            m.mcell_init_output(self._world)
            self._started = True
        if self._current_iteration <= self._iterations:
            m.mcell_run_iteration(self._world, self._output_freq, 0)
# You have to kill it now or it will hang
        if self._current_iteration == self._iterations:
            m.mcell_flush_data(self._world)
            m.mcell_print_final_warnings(self._world)
            m.mcell_print_final_statistics(self._world)
            self._finished = True
        self._current_iteration += 1

    def run_sim(self) -> None:
        """ Run the entire simulation without interruption. """
        if self._finished:
            print("The simulation is done running")
            return

        m.mcell_init_simulation(self._world)
        m.mcell_init_output(self._world)

        for i in range(self._iterations+1):
            m.mcell_run_iteration(self._world, self._output_freq, 0)
        m.mcell_flush_data(self._world)
        m.mcell_print_final_warnings(self._world)
        m.mcell_print_final_statistics(self._world)
        self._finished = True

    def end_sim(self) -> None:
        """ Call this if we end the simulation early """
        if self._started and not self._finished:
            m.mcell_flush_data(self._world)
            m.mcell_print_final_warnings(self._world)
            m.mcell_print_final_statistics(self._world)
            self._finished = True


def create_partitions(world, axis, start, stop, step):
    expr_list = m.num_expr_list_head()
    expr_list.value_head = None
    expr_list.value_tail = None
    expr_list.value_count = 0
    expr_list.shared = 1
    m.mcell_generate_range(expr_list, start, stop, step)
    expr_list.shared = 1
    m.mcell_set_partition(world, axis, expr_list)


def create_release_pattern(
    world, name, delay=0, release_interval=1e20, train_interval=1e20,
        train_duration=1e20, number_of_trains=1):
    """Create a release pattern

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        name -- name of the release pattern
        other arguments -- as listed
    """

    return m.mcell_create_release_pattern(
        world, name, delay, release_interval, train_interval, train_duration,
        number_of_trains)


def create_count(world, where, mol_sym, file_path, step):
    """Creates a count for a specified molecule in a specified region
    and initializes an output block for the count data that will be
    generated.

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        where (sym_entry) -- symbol entry for the location you want to
            record
        mol_sym (sym_entry) -- symbol entry for the molecule
        file_path (dir) -- name of the file path to output the data to
        step -- frequency of output in seconds

    Returns:
        The return values count list, output set, output times and
        output structure

    """
    report_flags = m.REPORT_CONTENTS
    c_list = m.output_column_list()
# XXX: m.ORIENT_NOT_SET is using -100 instead of SHRT_MIN (used typemap
# for mcell_create_count in mcell_react_out.i) because limits.h does not
# work well with swig
    count_list = m.mcell_create_count(
        world, mol_sym, m.ORIENT_NOT_SET, where, report_flags, None, c_list)

    os = m.output_set()
    os = m.mcell_create_new_output_set(
        None, 0, count_list.column_head, m.FILE_SUBSTITUTE, file_path)

    out_times = m.output_times_inlist()
    out_times.type = m.OUTPUT_BY_STEP
    out_times.step = step

    output = m.output_set_list()
    output.set_head = os
    output.set_tail = os

    m.mcell_add_reaction_output_block(world, output, 10000, out_times)

    return (count_list, os, out_times, output)


def create_species(world, name, D, is_2d, custom_time_step=0):
    """Creates a molecule species

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        name (string) -- Name of the molecule species that will be
            generated
        D (double) -- Diffusion Coefficient for the molecule species
            that will be generated.
        is_2d (bool) -- Boolean describing whether new species is a
            surface molecule
        custom_time_step -- Custom time step (< 0.0 for a custom space step,
                       >0.0 for custom timestep, 0.0 for default timestep)
    Returns:
        (mcell_symbol) Returns a species sym_entry

    """
    species_def = m.mcell_species_spec()
    species_def.name = name
    species_def.D = D
    is_2d = 1 if is_2d else 0
    species_def.is_2d = is_2d
    species_def.custom_time_step = custom_time_step
    species_def.target_only = 0
    species_def.max_step_length = 0

    species_temp_sym = m.mcell_symbol()
    species_sym = m.mcell_create_species(
        world, species_def, species_temp_sym)

    return species_sym


def create_reaction(
        world, reactants, products, rate_constant,
        backward_rate_constant=0.0, surf_class=None, name=None):
    """Creates a molecular reaction

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        reactants (mcell_species_list) -- list of species that are the
            reactants for the reaction
        products (mcell_species_list) -- list of species that are the
            products for the reaction
        rate_constant (double) -- the rate constant for the forward
            direction reaction -> product
        backward_rate_constant (double)(optional) -- the rate constant
            for the backward direction reaction <- product
        surf_class (mcell species list surface class)(optional) -- the
            surface class upon which the reaction will happen
        name (string)(optional) -- Name of the reaction

    Returns:
        void -- creates a reaction, by generating reaction_rates
            structure

    """

    if surf_class:
# Do nothing, surf_class has been added and a null object is not needed
        pass
    else:
        surf_class = m.mcell_add_to_species_list(None, False, 0, None)

    arrow = m.reaction_arrow()
# reversible reaction e.g. A<->B
    if backward_rate_constant:
        arrow.flags = m.ARROW_BIDIRECTIONAL
        rate_constant = m.mcell_create_reaction_rates(
            m.RATE_CONSTANT, rate_constant, m.RATE_CONSTANT,
            backward_rate_constant)
# irreversible reaction e.g. A->B
    else:
        arrow.flags = m.REGULAR_ARROW
        rate_constant = m.mcell_create_reaction_rates(
            m.RATE_CONSTANT, rate_constant, m.RATE_UNSET, 0)
    arrow.catalyst = m.mcell_species()
    arrow.catalyst.next = None
    arrow.catalyst.mol_type = None
    arrow.catalyst.orient_set = 0
    arrow.catalyst.orient = 0

    if (name):
        name_sym = m.mcell_new_rxn_pathname(world, name)
    else:
        name_sym = None
    m.mcell_add_reaction_simplified(
        world, reactants, arrow, surf_class, products, rate_constant, name_sym)


def create_instance_object(world, name):
    """Creates an instance object. Simple translation from wrapped code
    to python function. Frees the user from having to initialize the
    scene object and then pass it in and generate the object.

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        name (string) -- name of the instance object

    Returns:
        instance object

    """
    scene_temp = m.object()
    return m.mcell_create_instance_object(world, name, scene_temp)


def create_surf_class(world, name):
    """Creates a surface class. Simple translation from wrapped code to
    python function Frees the user from having to initialize the surface
    class symbol and then pass it in and generate the object.

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        name (string) -- name of the instance object

    Returns:
        mcell_symbol for surface class

    """

    sc_temp = m.mcell_symbol()
    return m.mcell_create_surf_class(world, name, sc_temp)


def create_list_release_site(
    world, scene, mol_list, xpos, ypos, zpos, name, surf_flags=None,
        orientations=None, diameter=1e-4):
    '''
    Creates a list release site
    All is self explanatory except mol_list:
    This is a list of "mol_sym" that you get back when you create the species.
    This is a Python list - it is converted to a species list in this function
    for you. By default, assumes all molecules are volume molecules. Else, need
    to pass surf_flags=[True,True,False,...] and their orientations =
    [1,0,1,...] Diameter is the diameter we search for to place a surface mol
    It can be None (= NULL in C) but then we do a poor job of placing surface
    mols
    '''

# Check that they're all the same length
    n = len(mol_list)
    if len(xpos) != n or len(ypos) != n or len(zpos) != n:
        raise ValueError("All lists must have the same length.")

# Check that if there are surface molecules
    if surf_flags is not None:
# Check that there are enough
        if len(surf_flags) != n or len(orientations) != n:
            raise ValueError(
                "surf_flags and orientations lists must have the same lengths "
                "as the others.")

# Convert to floats (can't be int)
    xpos = [float(q) for q in xpos]
    ypos = [float(q) for q in ypos]
    zpos = [float(q) for q in zpos]

# Diameter
    diam = m.vector3()
    diam.x = diameter
    diam.y = diameter
    diam.z = diameter

# Mols
    mol_list.reverse()
    species_list = None
# All volume molecules
    if surf_flags is None:
        for mol_sym in mol_list:
            species_list = m.mcell_add_to_species_list(
                mol_sym, False, 0, species_list)
    else:
        for i, mol_sym in enumerate(mol_list):
            species_list = m.mcell_add_to_species_list(
                mol_sym, surf_flags[i], orientations[i], species_list)

    rel_object = m.object()
    ret = m.mcell_create_list_release_site(
        world, scene, name, species_list, xpos, ypos, zpos, n, diam,
        rel_object)
# Delete the species list
    m.mcell_delete_species_list(species_list)

# VERY IMPORTANT HERE - MUST RETURN "ret"
# If we throw this away, all is lost....
    return (rel_object, ret)


def create_release_site(
        world, scene, pos, diam, shape, number, number_type, mol_sym, name):
    """Creates a molecule release site

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        scene (instance object) -- scene for mcell simulation
        pos (vector3) -- position of release site
        diam (vector3) -- diameter of release site
        number (int or float) -- number to be release at release site
        number_type (int) -- 0 for NUMBER, 1 for CONCENTRATION
        mol_sym (mcell_symbol) -- species to be released
        name (string) -- name of the release site

    Returns:
        void -- generates a species release site

    """

    position = m.vector3()
    position.x = pos.x
    position.y = pos.y
    position.z = pos.z
    diameter = m.vector3()
    diameter.x = diam.x
    diameter.y = diam.y
    diameter.z = diam.z

    mol_list = m.mcell_add_to_species_list(mol_sym, False, 0, None)
    rel_object = m.object()
    release_object = m.mcell_create_geometrical_release_site(
        world, scene, name, shape, position, diameter, mol_list, float(number),
        number_type, 1, None, rel_object)
    m.mcell_delete_species_list(mol_list)

    return (position, diameter, release_object)


def create_region_release_site(
        world, scene, mesh, release_name, reg_name, number, number_type,
        mol_sym):
    """Creates a release site on a specific region

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        scene (instance object) -- scene for mcell simulation
        mesh (mesh object) -- scene object where the release will occur
        release_name (string) -- name of the region release site
        reg_name (string) -- name of the region for the release site
        number (int or float) -- number to be released at the region release
            site
        number_type (int) -- 0 for NUMBER, 1 for CONCENTRATION
        mol_sym (mcell_symbol) -- species to be released

    Returns:
        release object (object)

    """

    mol_list = m.mcell_add_to_species_list(mol_sym, False, 0, None)
    rel_object = m.object()
    release_object = m.mcell_create_region_release(
        world, scene, mesh, release_name, reg_name, mol_list, float(number),
        number_type, 1, None, rel_object)
    m.mcell_delete_species_list(mol_list)

    return release_object


def create_box(world, scene, half_length, name):
    """Creates the verteces and lines of a cube object at the origin

    Args:
        half_length (double) -- half length of the cube

    Returns:
        vertex list and element connection list

    """

    hl = half_length
    verts = m.mcell_add_to_vertex_list(hl, hl, -hl, None)
    verts = m.mcell_add_to_vertex_list(hl, -hl, -hl, verts)
    verts = m.mcell_add_to_vertex_list(-hl, -hl, -hl, verts)
    verts = m.mcell_add_to_vertex_list(-hl, hl, -hl, verts)
    verts = m.mcell_add_to_vertex_list(hl, hl, hl, verts)
    verts = m.mcell_add_to_vertex_list(hl, -hl, hl, verts)
    verts = m.mcell_add_to_vertex_list(-hl, -hl, hl, verts)
    verts = m.mcell_add_to_vertex_list(-hl, hl, hl, verts)

    elems = m.mcell_add_to_connection_list(1, 2, 3, None)
    elems = m.mcell_add_to_connection_list(7, 6, 5, elems)
    elems = m.mcell_add_to_connection_list(0, 4, 5, elems)
    elems = m.mcell_add_to_connection_list(1, 5, 6, elems)
    elems = m.mcell_add_to_connection_list(6, 7, 3, elems)
    elems = m.mcell_add_to_connection_list(0, 3, 7, elems)
    elems = m.mcell_add_to_connection_list(0, 1, 3, elems)
    elems = m.mcell_add_to_connection_list(4, 7, 5, elems)
    elems = m.mcell_add_to_connection_list(1, 0, 5, elems)
    elems = m.mcell_add_to_connection_list(2, 1, 6, elems)
    elems = m.mcell_add_to_connection_list(2, 6, 3, elems)
    elems = m.mcell_add_to_connection_list(4, 0, 7, elems)

    pobj = m.poly_object()
    pobj.obj_name = name
    pobj.vertices = verts
    pobj.num_vert = 8
    pobj.connections = elems
    pobj.num_conn = 12

    mesh_temp = m.object()
    mesh = m.mcell_create_poly_object(world, scene, pobj, mesh_temp)

    return mesh


def change_geometry(world, scene_name, obj_list):

    pobj_list = None
    verts = None
    elems = None

    for p in obj_list:

        verts = None
        for x, y, z in p.vert_list:
            verts = m.mcell_add_to_vertex_list(x, y, z, verts)

        elems = None
        for x, y, z in p.face_list:
            elems = m.mcell_add_to_connection_list(x, y, z, elems)

        pobj = m.poly_object()
        pobj.obj_name = p.obj_name
        pobj.vertices = verts
        pobj.num_vert = len(p.vert_list)
        pobj.connections = elems
        pobj.num_conn = len(p.face_list)

        surf_reg_faces = None
        for idx in p.surf_reg_face_list:
            surf_reg_faces = m.mcell_add_to_region_list(surf_reg_faces, idx)

        pobj_list = m.mcell_add_to_poly_obj_list(
                pobj_list, p.obj_name, verts, len(p.vert_list), elems,
                len(p.face_list), surf_reg_faces, p.reg_name)

    m.mcell_change_geometry(world, pobj_list)


def create_polygon_object(world, vert_list, face_list, scene, name, translation=None):
    """Creates a polygon object from a vertex and element lest

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        vert_list (vertex list) -- verteces for the polygon
        face_list (element connection list) -- faces for the polygon
        scene (instance object) -- scene for mcell simulation
        name (string) -- name of polygon object that will be created

    Returns:
        polygon object
    """

    verts = None
    vert_list = vert_list[::-1]
    t = translation
    if t:
        for x, y, z in vert_list:
            verts = m.mcell_add_to_vertex_list(x+t[0], y+t[1], z+t[2], verts)
    else:
        for x, y, z in vert_list:
            verts = m.mcell_add_to_vertex_list(x, y, z, verts)

    elems = None
    face_list = face_list[::-1]
    for x, y, z in face_list:
        elems = m.mcell_add_to_connection_list(x, y, z, elems)

    pobj = m.poly_object()
    pobj.obj_name = name
    pobj.vertices = verts
    pobj.num_vert = len(vert_list)
    pobj.connections = elems
    pobj.num_conn = len(face_list)

    mesh_temp = m.object()
    mesh = m.mcell_create_poly_object(world, scene, pobj, mesh_temp)

    return mesh


def create_surface_region(world, mesh, surf_reg_face_list, region_name):
    """Creates a surface region

    Args:
        world (object) -- the world object which has been generated by
            mcell create_instance_object
        mesh (polygon object) -- object where surface region will reside
        surf_reg_face_list (element connection list) -- list of surface
            region faces
        region_name (string) -- name of the surface region being created

    Returns:
        region object

    """

    surface_region = m.mcell_create_region(world, mesh, region_name)

    surf_reg_faces = None
    for idx in surf_reg_face_list:
        surf_reg_faces = m.mcell_add_to_region_list(surf_reg_faces, idx)

    m.mcell_set_region_elements(surface_region, surf_reg_faces, 1)

    return surface_region

import pymcell as m
import json
import pickle
import logging
from typing import List, Dict, Tuple, Any


def read_json_data_model(file_name: str) -> Dict[str, Any]:
    """ Read a CellBlender data model in JSON format """
    with open(file_name, 'r') as f:
        json_model = f.read()
        data_model = json.loads(json_model)
    logging.info("Reading data model {}".format(file_name))
    return data_model


def read_pickle_data_model(file_name) -> Dict[str, Any]:
    """ Read a pickled CellBlender data model """
    pickle_model = pickle.load( open( file_name, "rb" ) )
    logging.info("Reading data model {}".format(file_name))
    return pickle_model


def create_species_from_dm(
        data_model: Dict[str, Any]) -> Dict[str, m.Species]:
    """ Create a dictionary of Species from a CB data model """
    logging.info("Creating species from data model")
    species_dm_list = data_model['mcell']['define_molecules']['molecule_list']
    species_dict = {}
    for species_dm in species_dm_list:
        species_name = species_dm['mol_name']
        dc = float(species_dm['diffusion_constant'])
        species_type = species_dm['mol_type']
        surface = False
        if species_type == '2D':
            surface = True
        species_dm = m.Species(species_name, dc, surface)
        species_dict[species_name] = species_dm
    return species_dict


def make_spec_orient_list(
        mol_str_list: List[str],
        species: Dict[str, m.Species]) -> List[Tuple[m.Species, m.Orient]]:
    spec_orient_list = []
    for r in mol_str_list:
        if r.endswith("'") or r.endswith(",") or r.endswith(";"):
            r_str = r[:-1]
            r_orient = r[-1]
            if r_orient == "'":
                orient = m.Orient.up
            elif r_orient == ",":
                orient = m.Orient.down
            elif r_orient == ";":
                orient = m.Orient.mix
            else:
                orient = m.Orient.mix
            spec = species[r_str]
            spec_orient_list.append(m.OrientedSpecies(spec, orient))
        else:
            spec = species[r]
            spec_orient_list.append(spec)
    return spec_orient_list


def create_reactions_from_dm(
        data_model: Dict[str, Any],
        species: Dict[str, m.Species]) -> List[m.Reaction]:
    """ Create a dictionary of Reactions from a CB data model """
    logging.info("Creating reactions from data model")
    rxn_dm_list = data_model['mcell']['define_reactions']['reaction_list']
    rxn_list = []
    for rxn_dm in rxn_dm_list:
# rxn_name = rxn_dm['rxn_name']
        fwd_rate = float(rxn_dm['fwd_rate'])
# try:
#     bkwd_rate = float(rxn_dm['bkwd_rate'])
# except ValueError:
#     pass
        reactants_str_list = rxn_dm['reactants'].split(" + ")
        products_str_list = rxn_dm['products'].split(" + ")
        r_list = make_spec_orient_list(reactants_str_list, species)
        p_list = make_spec_orient_list(products_str_list, species)
# rxn_type = rxn_dm['rxn_type']
        rxn_dm = m.Reaction(r_list, p_list, fwd_rate)
        rxn_list.append(rxn_dm)
    return rxn_list


def create_meshobjs_from_dm(
        dm: Dict[str, Any]) -> Dict[str, m.MeshObj]:
    """ Create a dictionary of MeshObj objects from a CB data model """
    logging.info("Creating mesh objects from data model")
    meshobj_dm_list = dm['mcell']['geometrical_objects']['object_list']
    meshobj_dict = {}
    for meshobj_dm in meshobj_dm_list:
        name = meshobj_dm['name']
        vert_list = meshobj_dm['vertex_list']
        face_list = meshobj_dm['element_connections']
        meshobj = m.MeshObj(name, vert_list, face_list)
        try:
            for reg_dm in meshobj_dm['define_surface_regions']:
                reg_name = reg_dm['name']
                face_list = reg_dm['include_elements']
                m.SurfaceRegion(meshobj, reg_name, face_list)
        except KeyError:
            pass
        meshobj_dict[name] = meshobj
    return meshobj_dict


def create_surface_classes_from_dm(
        dm: Dict[str, Any],
        world: m.MCellSim,
        spec_dict: Dict[str, m.Species]) -> Dict[str, m.SurfaceClass]:
    """ Create a dictionary of SurfaceClass objects from a CB data model """
    logging.info("Creating surface classes from data model")
    sc_dm_list = dm['mcell']['define_surface_classes']['surface_class_list']
    sc_dict = {}
    for sc_dm in sc_dm_list:
        sc_name = sc_dm['name']
        for sc_prop_dm in sc_dm['surface_class_prop_list']:
            if sc_prop_dm['affected_mols'] == 'SINGLE':
                spec_name = sc_prop_dm['molecule']
            else:
# XXX: Need to add in case for ALL_MOLECULES,
# ALL_SURFACE_MOLECULES, etc.
                pass
            spec = spec_dict[spec_name]
            sc_enums = {"TRANSPARENT": m.SC.transp , "REFLECTIVE": m.SC.reflect,  "ABSORPTIVE": m.SC.absorb }
            surf_class_type = sc_enums[sc_prop_dm['surf_class_type']]
            odict = {"'": Orient.up, ",": Orient.down, ";": Orient.mix}
            orient = odict[sc_prop_dm['surf_class_orient']]
            spec_orient = OrientedSpecies(spec, orient)
            sc = m.SurfaceClass(surf_class_type, spec_orient, name=sc_name)
            sc_dict[sc_name] = sc
    return sc_dict


def create_mod_surf_reg_from_dm(
        dm: Dict[str, Any],
        world: m.MCellSim,
        sc_dict: Dict[str, m.SurfaceClass],
        meshobj_dict: Dict[str, m.MeshObj]) -> None:
    logging.info("Creating surface region modifications from data model")
    mod_sr_list = dm['mcell']['modify_surface_regions']['modify_surface_regions_list']
    for mod_sr in mod_sr_list:
        object_name = mod_sr['object_name']
        region_name = mod_sr['region_name']
        surf_class_name = mod_sr['surf_class_name']
        sc = sc_dict[surf_class_name]
        meshobj = meshobj_dict[object_name]
        for reg in meshobj.regions:
            if reg.reg_name == region_name:
                world.assign_surf_class(sc, reg)
                break


def create_release_sites_from_dm(
        data_model: Dict[str, Any],
        world: m.MCellSim,
        meshobjs: Dict[str, m.MeshObj],
        species: Dict[str, m.Species]) -> None:
    logging.info("Creating release sites from data model")
    rel_site_dm_list = \
            data_model['mcell']['release_sites']['release_site_list']
    for rel_site_dm in rel_site_dm_list:
        rel_site_name = rel_site_dm['name']
        object_expr = rel_site_dm['object_expr']
        idx = object_expr.find("[")
        if idx > 0:
            object_name = object_expr[:idx]
            reg_name = object_expr[idx+1:-1]
        else:
            object_name = object_expr
            reg_name = ""
        meshobj = meshobjs[object_name]
        spec_name = rel_site_dm['molecule']
        spec = species[spec_name]
        quantity = int(rel_site_dm['quantity'])
        orient = rel_site_dm['orient']
        odict = {"'": Orient.up, ",": Orient.down, ";": Orient.mix}
        spec_orient = OrientedSpecies(spec, odict[orient])
# XXX: this is really clunky.
        reg = None
        for r in meshobj.regions:
            if r.reg_name == reg_name:
                reg = r
                break
        if reg:
            rel = m.ObjectRelease(spec_orient, number=quantity, region=reg)
        else:
            rel = m.ObjectRelease(spec_orient, number=quantity, mesh_obj=meshobj)
        world.release(rel)


def create_reaction_data_from_dm(
        data_model: Dict[str, Any],
        world: m.MCellSim,
        meshobjs: Dict[str, m.MeshObj],
        species: Dict[str, m.Species]) -> None:
    logging.info("Creating reactions from data model")
    rxn_out_dm_list = \
            data_model['mcell']['reaction_data_output']['reaction_output_list']
    for rxn_out_dm in rxn_out_dm_list:
        molecule_name = rxn_out_dm['molecule_name']
        spec = species[molecule_name]
        count_location = rxn_out_dm['count_location']
        if count_location == "Object":
            object_name = rxn_out_dm['object_name']
            meshobj = meshobjs[object_name]
            world.add_count(spec, mesh_obj=meshobj)
        elif count_location == "Region":
            region_name = rxn_out_dm['region_name']
            object_name = rxn_out_dm['object_name']
            meshobj = meshobjs[object_name]
            for reg in meshobj.regions:
                if reg.reg_name == region_name:
                    world.add_count(spec, reg=reg)
        else:
            world.add_count(spec)


def create_viz_data_from_dm(
        data_model: Dict,
        world: m.MCellSim,
        species: Dict[str, m.Species]) -> None:
    logging.info("Creating visualization data from data model")
    species_dm_list = data_model['mcell']['define_molecules']['molecule_list']
    export_all = data_model['mcell']['viz_output']['export_all']
    species_list = []
    for species_dm in species_dm_list:
        if export_all or species_dm['export_viz']:
            species_name = species_dm['mol_name']
            spec = species[species_name]
            species_list.append(spec)
    world.add_viz(species_list)


def create_initializations_from_dm(
        data_model: Dict,
        world: m.MCellSim) -> None:
    logging.info("Creating initializations from data model")
    initialization = data_model['mcell']['initialization']
    iterations = int(initialization['iterations'])
    time_step = float(initialization['time_step'])
    world.set_iterations(iterations)
    world.set_time_step(time_step)

MCELL_SUCCESS = _pymcell.MCELL_SUCCESS
MCELL_FAIL = _pymcell.MCELL_FAIL
class num_expr_list_head(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, num_expr_list_head, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, num_expr_list_head, name)
    __repr__ = _swig_repr
    __swig_setmethods__["value_head"] = _pymcell.num_expr_list_head_value_head_set
    __swig_getmethods__["value_head"] = _pymcell.num_expr_list_head_value_head_get
    if _newclass:
        value_head = _swig_property(_pymcell.num_expr_list_head_value_head_get, _pymcell.num_expr_list_head_value_head_set)
    __swig_setmethods__["value_tail"] = _pymcell.num_expr_list_head_value_tail_set
    __swig_getmethods__["value_tail"] = _pymcell.num_expr_list_head_value_tail_get
    if _newclass:
        value_tail = _swig_property(_pymcell.num_expr_list_head_value_tail_get, _pymcell.num_expr_list_head_value_tail_set)
    __swig_setmethods__["value_count"] = _pymcell.num_expr_list_head_value_count_set
    __swig_getmethods__["value_count"] = _pymcell.num_expr_list_head_value_count_get
    if _newclass:
        value_count = _swig_property(_pymcell.num_expr_list_head_value_count_get, _pymcell.num_expr_list_head_value_count_set)
    __swig_setmethods__["shared"] = _pymcell.num_expr_list_head_shared_set
    __swig_getmethods__["shared"] = _pymcell.num_expr_list_head_shared_get
    if _newclass:
        shared = _swig_property(_pymcell.num_expr_list_head_shared_get, _pymcell.num_expr_list_head_shared_set)

    def __init__(self, *args):
        """__init__(self) -> num_expr_list_head"""
        this = _pymcell.new_num_expr_list_head(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_num_expr_list_head
    __del__ = lambda self: None
num_expr_list_head_swigregister = _pymcell.num_expr_list_head_swigregister
num_expr_list_head_swigregister(num_expr_list_head)


def mcell_set_seed(state: 'MCELL_STATE *', seed: 'int') -> "void":
    return _pymcell.mcell_set_seed(state, seed)
mcell_set_seed = _pymcell.mcell_set_seed

def mcell_create() -> "MCELL_STATE *":
    return _pymcell.mcell_create()
mcell_create = _pymcell.mcell_create

def mcell_init_state(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_init_state(state)
mcell_init_state = _pymcell.mcell_init_state

def mcell_init_simulation(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_init_simulation(state)
mcell_init_simulation = _pymcell.mcell_init_simulation

def mcell_init_read_checkpoint(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_init_read_checkpoint(state)
mcell_init_read_checkpoint = _pymcell.mcell_init_read_checkpoint

def mcell_init_output(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_init_output(state)
mcell_init_output = _pymcell.mcell_init_output

def mcell_set_partition(state: 'MCELL_STATE *', dim: 'int', head: 'num_expr_list_head') -> "MCELL_STATUS":
    return _pymcell.mcell_set_partition(state, dim, head)
mcell_set_partition = _pymcell.mcell_set_partition

def mcell_set_time_step(state: 'MCELL_STATE *', step: 'double') -> "MCELL_STATUS":
    return _pymcell.mcell_set_time_step(state, step)
mcell_set_time_step = _pymcell.mcell_set_time_step

def mcell_set_iterations(state: 'MCELL_STATE *', iterations: 'long long') -> "MCELL_STATUS":
    return _pymcell.mcell_set_iterations(state, iterations)
mcell_set_iterations = _pymcell.mcell_set_iterations

def mcell_silence_notifications(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_silence_notifications(state)
mcell_silence_notifications = _pymcell.mcell_silence_notifications

def mcell_enable_notifications(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_enable_notifications(state)
mcell_enable_notifications = _pymcell.mcell_enable_notifications

def mcell_silence_warnings(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_silence_warnings(state)
mcell_silence_warnings = _pymcell.mcell_silence_warnings

def mcell_enable_warnings(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_enable_warnings(state)
mcell_enable_warnings = _pymcell.mcell_enable_warnings

def mcell_print_version() -> "void":
    return _pymcell.mcell_print_version()
mcell_print_version = _pymcell.mcell_print_version

def mcell_print_usage(executable_name: 'char const *') -> "void":
    return _pymcell.mcell_print_usage(executable_name)
mcell_print_usage = _pymcell.mcell_print_usage

def mcell_print_stats() -> "void":
    return _pymcell.mcell_print_stats()
mcell_print_stats = _pymcell.mcell_print_stats

def mcell_argparse(argc: 'int', argv: 'char **', state: 'MCELL_STATE *') -> "int":
    return _pymcell.mcell_argparse(argc, argv, state)
mcell_argparse = _pymcell.mcell_argparse

def mcell_copysort_numeric_list(head: 'num_expr_list') -> "struct num_expr_list *":
    return _pymcell.mcell_copysort_numeric_list(head)
mcell_copysort_numeric_list = _pymcell.mcell_copysort_numeric_list

def mcell_sort_numeric_list(head: 'num_expr_list') -> "void":
    return _pymcell.mcell_sort_numeric_list(head)
mcell_sort_numeric_list = _pymcell.mcell_sort_numeric_list

def mcell_free_numeric_list(nel: 'num_expr_list') -> "void":
    return _pymcell.mcell_free_numeric_list(nel)
mcell_free_numeric_list = _pymcell.mcell_free_numeric_list

def mcell_generate_range(list: 'num_expr_list_head', start: 'double', end: 'double', step: 'double') -> "MCELL_STATUS":
    return _pymcell.mcell_generate_range(list, start, end, step)
mcell_generate_range = _pymcell.mcell_generate_range

def mcell_generate_range_singleton(lh: 'num_expr_list_head', value: 'double') -> "int":
    return _pymcell.mcell_generate_range_singleton(lh, value)
mcell_generate_range_singleton = _pymcell.mcell_generate_range_singleton

def mcell_print(message: 'char const *') -> "void":
    return _pymcell.mcell_print(message)
mcell_print = _pymcell.mcell_print
class object_creation(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, object_creation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, object_creation, name)
    __repr__ = _swig_repr
    __swig_setmethods__["object_name_list"] = _pymcell.object_creation_object_name_list_set
    __swig_getmethods__["object_name_list"] = _pymcell.object_creation_object_name_list_get
    if _newclass:
        object_name_list = _swig_property(_pymcell.object_creation_object_name_list_get, _pymcell.object_creation_object_name_list_set)
    __swig_setmethods__["object_name_list_end"] = _pymcell.object_creation_object_name_list_end_set
    __swig_getmethods__["object_name_list_end"] = _pymcell.object_creation_object_name_list_end_get
    if _newclass:
        object_name_list_end = _swig_property(_pymcell.object_creation_object_name_list_end_get, _pymcell.object_creation_object_name_list_end_set)
    __swig_setmethods__["current_object"] = _pymcell.object_creation_current_object_set
    __swig_getmethods__["current_object"] = _pymcell.object_creation_current_object_get
    if _newclass:
        current_object = _swig_property(_pymcell.object_creation_current_object_get, _pymcell.object_creation_current_object_set)

    def __init__(self, *args):
        """__init__(self) -> object_creation"""
        this = _pymcell.new_object_creation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_object_creation
    __del__ = lambda self: None
object_creation_swigregister = _pymcell.object_creation_swigregister
object_creation_swigregister(object_creation)

class poly_object(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, poly_object, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, poly_object, name)
    __repr__ = _swig_repr
    __swig_setmethods__["obj_name"] = _pymcell.poly_object_obj_name_set
    __swig_getmethods__["obj_name"] = _pymcell.poly_object_obj_name_get
    if _newclass:
        obj_name = _swig_property(_pymcell.poly_object_obj_name_get, _pymcell.poly_object_obj_name_set)
    __swig_setmethods__["vertices"] = _pymcell.poly_object_vertices_set
    __swig_getmethods__["vertices"] = _pymcell.poly_object_vertices_get
    if _newclass:
        vertices = _swig_property(_pymcell.poly_object_vertices_get, _pymcell.poly_object_vertices_set)
    __swig_setmethods__["num_vert"] = _pymcell.poly_object_num_vert_set
    __swig_getmethods__["num_vert"] = _pymcell.poly_object_num_vert_get
    if _newclass:
        num_vert = _swig_property(_pymcell.poly_object_num_vert_get, _pymcell.poly_object_num_vert_set)
    __swig_setmethods__["connections"] = _pymcell.poly_object_connections_set
    __swig_getmethods__["connections"] = _pymcell.poly_object_connections_get
    if _newclass:
        connections = _swig_property(_pymcell.poly_object_connections_get, _pymcell.poly_object_connections_set)
    __swig_setmethods__["num_conn"] = _pymcell.poly_object_num_conn_set
    __swig_getmethods__["num_conn"] = _pymcell.poly_object_num_conn_get
    if _newclass:
        num_conn = _swig_property(_pymcell.poly_object_num_conn_get, _pymcell.poly_object_num_conn_set)

    def __init__(self, *args):
        """__init__(self) -> poly_object"""
        this = _pymcell.new_poly_object(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_poly_object
    __del__ = lambda self: None
poly_object_swigregister = _pymcell.poly_object_swigregister
poly_object_swigregister(poly_object)

class poly_object_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, poly_object_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, poly_object_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["obj_name"] = _pymcell.poly_object_list_obj_name_set
    __swig_getmethods__["obj_name"] = _pymcell.poly_object_list_obj_name_get
    if _newclass:
        obj_name = _swig_property(_pymcell.poly_object_list_obj_name_get, _pymcell.poly_object_list_obj_name_set)
    __swig_setmethods__["vertices"] = _pymcell.poly_object_list_vertices_set
    __swig_getmethods__["vertices"] = _pymcell.poly_object_list_vertices_get
    if _newclass:
        vertices = _swig_property(_pymcell.poly_object_list_vertices_get, _pymcell.poly_object_list_vertices_set)
    __swig_setmethods__["num_vert"] = _pymcell.poly_object_list_num_vert_set
    __swig_getmethods__["num_vert"] = _pymcell.poly_object_list_num_vert_get
    if _newclass:
        num_vert = _swig_property(_pymcell.poly_object_list_num_vert_get, _pymcell.poly_object_list_num_vert_set)
    __swig_setmethods__["connections"] = _pymcell.poly_object_list_connections_set
    __swig_getmethods__["connections"] = _pymcell.poly_object_list_connections_get
    if _newclass:
        connections = _swig_property(_pymcell.poly_object_list_connections_get, _pymcell.poly_object_list_connections_set)
    __swig_setmethods__["num_conn"] = _pymcell.poly_object_list_num_conn_set
    __swig_getmethods__["num_conn"] = _pymcell.poly_object_list_num_conn_get
    if _newclass:
        num_conn = _swig_property(_pymcell.poly_object_list_num_conn_get, _pymcell.poly_object_list_num_conn_set)
    __swig_setmethods__["surf_reg_faces"] = _pymcell.poly_object_list_surf_reg_faces_set
    __swig_getmethods__["surf_reg_faces"] = _pymcell.poly_object_list_surf_reg_faces_get
    if _newclass:
        surf_reg_faces = _swig_property(_pymcell.poly_object_list_surf_reg_faces_get, _pymcell.poly_object_list_surf_reg_faces_set)
    __swig_setmethods__["reg_name"] = _pymcell.poly_object_list_reg_name_set
    __swig_getmethods__["reg_name"] = _pymcell.poly_object_list_reg_name_get
    if _newclass:
        reg_name = _swig_property(_pymcell.poly_object_list_reg_name_get, _pymcell.poly_object_list_reg_name_set)
    __swig_setmethods__["next"] = _pymcell.poly_object_list_next_set
    __swig_getmethods__["next"] = _pymcell.poly_object_list_next_get
    if _newclass:
        next = _swig_property(_pymcell.poly_object_list_next_get, _pymcell.poly_object_list_next_set)

    def __init__(self, *args):
        """__init__(self) -> poly_object_list"""
        this = _pymcell.new_poly_object_list(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_poly_object_list
    __del__ = lambda self: None
poly_object_list_swigregister = _pymcell.poly_object_list_swigregister
poly_object_list_swigregister(poly_object_list)


def mcell_create_instance_object(state: 'MCELL_STATE *', name: 'char *', new_object: 'struct object **') -> "struct object **":
    return _pymcell.mcell_create_instance_object(state, name, new_object)
mcell_create_instance_object = _pymcell.mcell_create_instance_object

def mcell_create_poly_object(state: 'MCELL_STATE *', parent: 'object', poly_obj: 'poly_object', new_object: 'struct object **') -> "struct object **":
    return _pymcell.mcell_create_poly_object(state, parent, poly_obj, new_object)
mcell_create_poly_object = _pymcell.mcell_create_poly_object

def new_polygon_list(state: 'MCELL_STATE *', obj_ptr: 'object', n_vertices: 'int', vertices: 'struct vertex_list *', n_connections: 'int', connections: 'struct element_connection_list *') -> "struct polygon_object *":
    return _pymcell.new_polygon_list(state, obj_ptr, n_vertices, vertices, n_connections, connections)
new_polygon_list = _pymcell.new_polygon_list

def make_new_object(dg_parse: 'struct dyngeom_parse_vars *', obj_sym_table: 'sym_table_head', obj_name: 'char *', error_code: 'int *') -> "struct object *":
    return _pymcell.make_new_object(dg_parse, obj_sym_table, obj_name, error_code)
make_new_object = _pymcell.make_new_object

def push_object_name(obj_creation: 'object_creation', name: 'char *') -> "char *":
    return _pymcell.push_object_name(obj_creation, name)
push_object_name = _pymcell.push_object_name

def pop_object_name(obj_creation: 'object_creation') -> "void":
    return _pymcell.pop_object_name(obj_creation)
pop_object_name = _pymcell.pop_object_name

def mcell_add_to_vertex_list(x: 'double', y: 'double', z: 'double', vertices: 'struct vertex_list *') -> "struct vertex_list *":
    return _pymcell.mcell_add_to_vertex_list(x, y, z, vertices)
mcell_add_to_vertex_list = _pymcell.mcell_add_to_vertex_list

def free_vertex_list(vert_list: 'struct vertex_list *') -> "void":
    return _pymcell.free_vertex_list(vert_list)
free_vertex_list = _pymcell.free_vertex_list

def mcell_add_to_connection_list(v1: 'int', v2: 'int', v3: 'int', elements: 'struct element_connection_list *') -> "struct element_connection_list *":
    return _pymcell.mcell_add_to_connection_list(v1, v2, v3, elements)
mcell_add_to_connection_list = _pymcell.mcell_add_to_connection_list

def free_connection_list(elem_conn_list: 'struct element_connection_list *') -> "void":
    return _pymcell.free_connection_list(elem_conn_list)
free_connection_list = _pymcell.free_connection_list

def mcell_set_region_elements(rgn: 'struct region *', elements: 'struct element_list *', normalize_now: 'int') -> "int":
    return _pymcell.mcell_set_region_elements(rgn, elements, normalize_now)
mcell_set_region_elements = _pymcell.mcell_set_region_elements

def mcell_add_to_region_list(elements: 'struct element_list *', region_idx: 'unsigned int') -> "struct element_list *":
    return _pymcell.mcell_add_to_region_list(elements, region_idx)
mcell_add_to_region_list = _pymcell.mcell_add_to_region_list

def add_child_objects(parent: 'object', child_head: 'object', child_tail: 'object') -> "void":
    return _pymcell.add_child_objects(parent, child_head, child_tail)
add_child_objects = _pymcell.add_child_objects

def mcell_create_region(state: 'MCELL_STATE *', objp: 'object', name: 'char *') -> "struct region *":
    return _pymcell.mcell_create_region(state, objp, name)
mcell_create_region = _pymcell.mcell_create_region

def make_new_region(dg_parse: 'struct dyngeom_parse_vars *', state: 'MCELL_STATE *', obj_name: 'char *', region_last_name: 'char *') -> "struct region *":
    return _pymcell.make_new_region(dg_parse, state, obj_name, region_last_name)
make_new_region = _pymcell.make_new_region

def remove_gaps_from_regions(obj_ptr: 'object') -> "void":
    return _pymcell.remove_gaps_from_regions(obj_ptr)
remove_gaps_from_regions = _pymcell.remove_gaps_from_regions

def check_degenerate_polygon_list(obj_ptr: 'object') -> "int":
    return _pymcell.check_degenerate_polygon_list(obj_ptr)
check_degenerate_polygon_list = _pymcell.check_degenerate_polygon_list

def common_ancestor(a: 'object', b: 'object') -> "struct object *":
    return _pymcell.common_ancestor(a, b)
common_ancestor = _pymcell.common_ancestor

def allocate_polygon_object(desc: 'char const *') -> "struct polygon_object *":
    return _pymcell.allocate_polygon_object(desc)
allocate_polygon_object = _pymcell.allocate_polygon_object

def new_element_list(begin: 'unsigned int', end: 'unsigned int') -> "struct element_list *":
    return _pymcell.new_element_list(begin, end)
new_element_list = _pymcell.new_element_list

def normalize_elements(reg: 'struct region *', existing: 'int') -> "int":
    return _pymcell.normalize_elements(reg, existing)
normalize_elements = _pymcell.normalize_elements

def count_cuboid_elements(sb: 'struct subdivided_box *') -> "int":
    return _pymcell.count_cuboid_elements(sb)
count_cuboid_elements = _pymcell.count_cuboid_elements

def cuboid_patch_to_bits(subd_box: 'struct subdivided_box *', v1: 'vector3', v2: 'vector3', bit_arr: 'struct bit_array *') -> "int":
    return _pymcell.cuboid_patch_to_bits(subd_box, v1, v2, bit_arr)
cuboid_patch_to_bits = _pymcell.cuboid_patch_to_bits

def check_patch(b: 'struct subdivided_box *', p1: 'vector3', p2: 'vector3', egd: 'double') -> "int":
    return _pymcell.check_patch(b, p1, p2, egd)
check_patch = _pymcell.check_patch

def mcell_get_obj_sym(obj: 'object') -> "struct sym_entry *":
    return _pymcell.mcell_get_obj_sym(obj)
mcell_get_obj_sym = _pymcell.mcell_get_obj_sym

def mcell_get_reg_sym(reg: 'struct region *') -> "struct sym_entry *":
    return _pymcell.mcell_get_reg_sym(reg)
mcell_get_reg_sym = _pymcell.mcell_get_reg_sym

def mcell_get_all_mol_sym(state: 'MCELL_STATE *') -> "struct sym_entry *":
    return _pymcell.mcell_get_all_mol_sym(state)
mcell_get_all_mol_sym = _pymcell.mcell_get_all_mol_sym

def mcell_get_all_volume_mol_sym(state: 'MCELL_STATE *') -> "struct sym_entry *":
    return _pymcell.mcell_get_all_volume_mol_sym(state)
mcell_get_all_volume_mol_sym = _pymcell.mcell_get_all_volume_mol_sym

def mcell_get_all_surface_mol_sym(state: 'MCELL_STATE *') -> "struct sym_entry *":
    return _pymcell.mcell_get_all_surface_mol_sym(state)
mcell_get_all_surface_mol_sym = _pymcell.mcell_get_all_surface_mol_sym

def mcell_add_to_poly_obj_list(poly_obj_list: 'poly_object_list', obj_name: 'char *', vertices: 'struct vertex_list *', num_vert: 'int', connections: 'struct element_connection_list *', num_conn: 'int', surf_reg_faces: 'struct element_list *', reg_name: 'char *') -> "struct poly_object_list *":
    return _pymcell.mcell_add_to_poly_obj_list(poly_obj_list, obj_name, vertices, num_vert, connections, num_conn, surf_reg_faces, reg_name)
mcell_add_to_poly_obj_list = _pymcell.mcell_add_to_poly_obj_list
class output_column_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_column_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_column_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["column_head"] = _pymcell.output_column_list_column_head_set
    __swig_getmethods__["column_head"] = _pymcell.output_column_list_column_head_get
    if _newclass:
        column_head = _swig_property(_pymcell.output_column_list_column_head_get, _pymcell.output_column_list_column_head_set)
    __swig_setmethods__["column_tail"] = _pymcell.output_column_list_column_tail_set
    __swig_getmethods__["column_tail"] = _pymcell.output_column_list_column_tail_get
    if _newclass:
        column_tail = _swig_property(_pymcell.output_column_list_column_tail_get, _pymcell.output_column_list_column_tail_set)

    def __init__(self, *args):
        """__init__(self) -> output_column_list"""
        this = _pymcell.new_output_column_list(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_output_column_list
    __del__ = lambda self: None
output_column_list_swigregister = _pymcell.output_column_list_swigregister
output_column_list_swigregister(output_column_list)

class output_set_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_set_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_set_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["set_head"] = _pymcell.output_set_list_set_head_set
    __swig_getmethods__["set_head"] = _pymcell.output_set_list_set_head_get
    if _newclass:
        set_head = _swig_property(_pymcell.output_set_list_set_head_get, _pymcell.output_set_list_set_head_set)
    __swig_setmethods__["set_tail"] = _pymcell.output_set_list_set_tail_set
    __swig_getmethods__["set_tail"] = _pymcell.output_set_list_set_tail_get
    if _newclass:
        set_tail = _swig_property(_pymcell.output_set_list_set_tail_get, _pymcell.output_set_list_set_tail_set)

    def __init__(self, *args):
        """__init__(self) -> output_set_list"""
        this = _pymcell.new_output_set_list(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_output_set_list
    __del__ = lambda self: None
output_set_list_swigregister = _pymcell.output_set_list_swigregister
output_set_list_swigregister(output_set_list)

class output_times_inlist(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_times_inlist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_times_inlist, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _pymcell.output_times_inlist_type_set
    __swig_getmethods__["type"] = _pymcell.output_times_inlist_type_get
    if _newclass:
        type = _swig_property(_pymcell.output_times_inlist_type_get, _pymcell.output_times_inlist_type_set)
    __swig_setmethods__["step"] = _pymcell.output_times_inlist_step_set
    __swig_getmethods__["step"] = _pymcell.output_times_inlist_step_get
    if _newclass:
        step = _swig_property(_pymcell.output_times_inlist_step_get, _pymcell.output_times_inlist_step_set)
    __swig_setmethods__["values"] = _pymcell.output_times_inlist_values_set
    __swig_getmethods__["values"] = _pymcell.output_times_inlist_values_get
    if _newclass:
        values = _swig_property(_pymcell.output_times_inlist_values_get, _pymcell.output_times_inlist_values_set)

    def __init__(self, *args):
        """__init__(self) -> output_times_inlist"""
        this = _pymcell.new_output_times_inlist(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_output_times_inlist
    __del__ = lambda self: None
output_times_inlist_swigregister = _pymcell.output_times_inlist_swigregister
output_times_inlist_swigregister(output_times_inlist)


def mcell_get_count(mol_name: 'char *', reg_name: 'char *', world: 'struct volume *') -> "int":
    return _pymcell.mcell_get_count(mol_name, reg_name, world)
mcell_get_count = _pymcell.mcell_get_count

def mcell_new_output_request(state: 'MCELL_STATE *', target: 'mcell_symbol', orientation: 'short', location: 'mcell_symbol', img: 'struct periodic_image *', report_flags: 'int') -> "struct output_request *":
    return _pymcell.mcell_new_output_request(state, target, orientation, location, img, report_flags)
mcell_new_output_request = _pymcell.mcell_new_output_request

def mcell_create_new_output_set(comment: 'char *', exact_time: 'int', col_head: 'struct output_column *', file_flags: 'int', outfile_name: 'char *') -> "struct output_set *":
    return _pymcell.mcell_create_new_output_set(comment, exact_time, col_head, file_flags, outfile_name)
mcell_create_new_output_set = _pymcell.mcell_create_new_output_set

def mcell_prepare_single_count_expr(list: 'output_column_list', expr: 'struct output_expression *', custom_header: 'char *') -> "MCELL_STATUS":
    return _pymcell.mcell_prepare_single_count_expr(list, expr, custom_header)
mcell_prepare_single_count_expr = _pymcell.mcell_prepare_single_count_expr

def mcell_add_reaction_output_block(state: 'MCELL_STATE *', osets: 'output_set_list', buffer_size: 'int', otimes: 'output_times_inlist') -> "MCELL_STATUS":
    return _pymcell.mcell_add_reaction_output_block(state, osets, buffer_size, otimes)
mcell_add_reaction_output_block = _pymcell.mcell_add_reaction_output_block

def mcell_create_count(state: 'MCELL_STATE *', target: 'mcell_symbol', orientation: 'short', location: 'mcell_symbol', report_flags: 'int', custom_header: 'char *', count_list: 'output_column_list') -> "struct output_column_list *":
    return _pymcell.mcell_create_count(state, target, orientation, location, report_flags, custom_header, count_list)
mcell_create_count = _pymcell.mcell_create_count

def mcell_get_counter_value(state: 'MCELL_STATE *', counter_name: 'char const *', column: 'int', count_data: 'double *', count_data_type: 'enum count_type_t *') -> "MCELL_STATUS":
    return _pymcell.mcell_get_counter_value(state, counter_name, column, count_data, count_data_type)
mcell_get_counter_value = _pymcell.mcell_get_counter_value
REGULAR_ARROW = _pymcell.REGULAR_ARROW
ARROW_BIDIRECTIONAL = _pymcell.ARROW_BIDIRECTIONAL
ARROW_CATALYTIC = _pymcell.ARROW_CATALYTIC
RATE_UNSET = _pymcell.RATE_UNSET
RATE_CONSTANT = _pymcell.RATE_CONSTANT
RATE_FILE = _pymcell.RATE_FILE
RFLCT = _pymcell.RFLCT
TRANSP = _pymcell.TRANSP
SINK = _pymcell.SINK
class reaction_def(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_def, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_def, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sym"] = _pymcell.reaction_def_sym_set
    __swig_getmethods__["sym"] = _pymcell.reaction_def_sym_get
    if _newclass:
        sym = _swig_property(_pymcell.reaction_def_sym_get, _pymcell.reaction_def_sym_set)

    def __init__(self, *args):
        """__init__(self) -> reaction_def"""
        this = _pymcell.new_reaction_def(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_def
    __del__ = lambda self: None
reaction_def_swigregister = _pymcell.reaction_def_swigregister
reaction_def_swigregister(reaction_def)

class release_single_molecule_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, release_single_molecule_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, release_single_molecule_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rsm_head"] = _pymcell.release_single_molecule_list_rsm_head_set
    __swig_getmethods__["rsm_head"] = _pymcell.release_single_molecule_list_rsm_head_get
    if _newclass:
        rsm_head = _swig_property(_pymcell.release_single_molecule_list_rsm_head_get, _pymcell.release_single_molecule_list_rsm_head_set)
    __swig_setmethods__["rsm_tail"] = _pymcell.release_single_molecule_list_rsm_tail_set
    __swig_getmethods__["rsm_tail"] = _pymcell.release_single_molecule_list_rsm_tail_get
    if _newclass:
        rsm_tail = _swig_property(_pymcell.release_single_molecule_list_rsm_tail_get, _pymcell.release_single_molecule_list_rsm_tail_set)
    __swig_setmethods__["rsm_count"] = _pymcell.release_single_molecule_list_rsm_count_set
    __swig_getmethods__["rsm_count"] = _pymcell.release_single_molecule_list_rsm_count_get
    if _newclass:
        rsm_count = _swig_property(_pymcell.release_single_molecule_list_rsm_count_get, _pymcell.release_single_molecule_list_rsm_count_set)

    def __init__(self, *args):
        """__init__(self) -> release_single_molecule_list"""
        this = _pymcell.new_release_single_molecule_list(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_release_single_molecule_list
    __del__ = lambda self: None
release_single_molecule_list_swigregister = _pymcell.release_single_molecule_list_swigregister
release_single_molecule_list_swigregister(release_single_molecule_list)

class reaction_arrow(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_arrow, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_arrow, name)
    __repr__ = _swig_repr
    __swig_setmethods__["flags"] = _pymcell.reaction_arrow_flags_set
    __swig_getmethods__["flags"] = _pymcell.reaction_arrow_flags_get
    if _newclass:
        flags = _swig_property(_pymcell.reaction_arrow_flags_get, _pymcell.reaction_arrow_flags_set)
    __swig_setmethods__["catalyst"] = _pymcell.reaction_arrow_catalyst_set
    __swig_getmethods__["catalyst"] = _pymcell.reaction_arrow_catalyst_get
    if _newclass:
        catalyst = _swig_property(_pymcell.reaction_arrow_catalyst_get, _pymcell.reaction_arrow_catalyst_set)

    def __init__(self, *args):
        """__init__(self) -> reaction_arrow"""
        this = _pymcell.new_reaction_arrow(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_arrow
    __del__ = lambda self: None
reaction_arrow_swigregister = _pymcell.reaction_arrow_swigregister
reaction_arrow_swigregister(reaction_arrow)

class reaction_rate(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_rate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_rate, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rate_type"] = _pymcell.reaction_rate_rate_type_set
    __swig_getmethods__["rate_type"] = _pymcell.reaction_rate_rate_type_get
    if _newclass:
        rate_type = _swig_property(_pymcell.reaction_rate_rate_type_get, _pymcell.reaction_rate_rate_type_set)
    __swig_getmethods__["v"] = _pymcell.reaction_rate_v_get
    if _newclass:
        v = _swig_property(_pymcell.reaction_rate_v_get)

    def __init__(self, *args):
        """__init__(self) -> reaction_rate"""
        this = _pymcell.new_reaction_rate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_rate
    __del__ = lambda self: None
reaction_rate_swigregister = _pymcell.reaction_rate_swigregister
reaction_rate_swigregister(reaction_rate)

class reaction_rate_v(_object):
    """Proxy of C reaction_rate_v struct."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_rate_v, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_rate_v, name)
    __repr__ = _swig_repr
    __swig_setmethods__["rate_constant"] = _pymcell.reaction_rate_v_rate_constant_set
    __swig_getmethods__["rate_constant"] = _pymcell.reaction_rate_v_rate_constant_get
    if _newclass:
        rate_constant = _swig_property(_pymcell.reaction_rate_v_rate_constant_get, _pymcell.reaction_rate_v_rate_constant_set)
    __swig_setmethods__["rate_file"] = _pymcell.reaction_rate_v_rate_file_set
    __swig_getmethods__["rate_file"] = _pymcell.reaction_rate_v_rate_file_get
    if _newclass:
        rate_file = _swig_property(_pymcell.reaction_rate_v_rate_file_get, _pymcell.reaction_rate_v_rate_file_set)

    def __init__(self, *args):
        """__init__(self) -> reaction_rate_v"""
        this = _pymcell.new_reaction_rate_v(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_rate_v
    __del__ = lambda self: None
reaction_rate_v_swigregister = _pymcell.reaction_rate_v_swigregister
reaction_rate_v_swigregister(reaction_rate_v)

class reaction_rates(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, reaction_rates, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, reaction_rates, name)
    __repr__ = _swig_repr
    __swig_setmethods__["forward_rate"] = _pymcell.reaction_rates_forward_rate_set
    __swig_getmethods__["forward_rate"] = _pymcell.reaction_rates_forward_rate_get
    if _newclass:
        forward_rate = _swig_property(_pymcell.reaction_rates_forward_rate_get, _pymcell.reaction_rates_forward_rate_set)
    __swig_setmethods__["backward_rate"] = _pymcell.reaction_rates_backward_rate_set
    __swig_getmethods__["backward_rate"] = _pymcell.reaction_rates_backward_rate_get
    if _newclass:
        backward_rate = _swig_property(_pymcell.reaction_rates_backward_rate_get, _pymcell.reaction_rates_backward_rate_set)

    def __init__(self, *args):
        """__init__(self) -> reaction_rates"""
        this = _pymcell.new_reaction_rates(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_reaction_rates
    __del__ = lambda self: None
reaction_rates_swigregister = _pymcell.reaction_rates_swigregister
reaction_rates_swigregister(reaction_rates)


def mcell_modify_multiple_rate_constants(world: 'struct volume *', names: 'char **', rate_constants: 'double *', n_rxns: 'int') -> "MCELL_STATUS":
    return _pymcell.mcell_modify_multiple_rate_constants(world, names, rate_constants, n_rxns)
mcell_modify_multiple_rate_constants = _pymcell.mcell_modify_multiple_rate_constants

def mcell_modify_rate_constant(world: 'struct volume *', name: 'char *', rate: 'double') -> "MCELL_STATUS":
    return _pymcell.mcell_modify_rate_constant(world, name, rate)
mcell_modify_rate_constant = _pymcell.mcell_modify_rate_constant

def mcell_add_reaction_simplified(state: 'struct volume *', reactants: 'mcell_species', arrow: 'reaction_arrow', surfs: 'mcell_species', products: 'mcell_species', rates: 'reaction_rates', pathname: 'mcell_symbol') -> "MCELL_STATUS":
    return _pymcell.mcell_add_reaction_simplified(state, reactants, arrow, surfs, products, rates, pathname)
mcell_add_reaction_simplified = _pymcell.mcell_add_reaction_simplified

def mcell_add_reaction(notify: 'struct notifications *', r_step_release: 'double **', rxn_sym_table: 'sym_table_head', radial_subdivisions: 'u_int', vacancy_search_dist2: 'double', reactants: 'mcell_species', react_arrow: 'reaction_arrow', surf_class: 'mcell_species', products: 'mcell_species', pathname: 'mcell_symbol', rates: 'reaction_rates', forward_rate_filename: 'char const *', backward_rate_filename: 'char const *') -> "MCELL_STATUS":
    return _pymcell.mcell_add_reaction(notify, r_step_release, rxn_sym_table, radial_subdivisions, vacancy_search_dist2, reactants, react_arrow, surf_class, products, pathname, rates, forward_rate_filename, backward_rate_filename)
mcell_add_reaction = _pymcell.mcell_add_reaction

def mcell_add_surface_reaction(rxn_sym_table: 'sym_table_head', reaction_type: 'int', surface_class: 'struct species *', reactant_sym: 'mcell_symbol', orient: 'short') -> "MCELL_STATUS":
    return _pymcell.mcell_add_surface_reaction(rxn_sym_table, reaction_type, surface_class, reactant_sym, orient)
mcell_add_surface_reaction = _pymcell.mcell_add_surface_reaction

def mcell_add_concentration_clamp(rxn_sym_table: 'sym_table_head', surface_class: 'struct species *', mol_sym: 'mcell_symbol', orient: 'short', conc: 'double') -> "MCELL_STATUS":
    return _pymcell.mcell_add_concentration_clamp(rxn_sym_table, surface_class, mol_sym, orient, conc)
mcell_add_concentration_clamp = _pymcell.mcell_add_concentration_clamp

def init_reactions(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.init_reactions(state)
init_reactions = _pymcell.init_reactions

def mcell_change_reaction_rate(state: 'MCELL_STATE *', reaction_name: 'char const *', new_rate: 'double') -> "MCELL_STATUS":
    return _pymcell.mcell_change_reaction_rate(state, reaction_name, new_rate)
mcell_change_reaction_rate = _pymcell.mcell_change_reaction_rate

def mcell_create_reaction_rates(forwardRateType: 'int', forwardRate: 'double', backwardRateType: 'int', backwardRate: 'double') -> "struct reaction_rates":
    return _pymcell.mcell_create_reaction_rates(forwardRateType, forwardRate, backwardRateType, backwardRate)
mcell_create_reaction_rates = _pymcell.mcell_create_reaction_rates

def mcell_new_rxn_pathname(state: 'struct volume *', name: 'char *') -> "struct sym_entry *":
    return _pymcell.mcell_new_rxn_pathname(state, name)
mcell_new_rxn_pathname = _pymcell.mcell_new_rxn_pathname

def mcell_create_list_release_site(state: 'MCELL_STATE *', parent: 'object', site_name: 'char *', mol: 'mcell_species', x_pos: 'double *', y_pos: 'double *', z_pos: 'double *', n_site: 'int', diameter: 'vector3', new_object: 'struct object **') -> "struct object **":
    return _pymcell.mcell_create_list_release_site(state, parent, site_name, mol, x_pos, y_pos, z_pos, n_site, diameter, new_object)
mcell_create_list_release_site = _pymcell.mcell_create_list_release_site

def mcell_create_geometrical_release_site(state: 'MCELL_STATE *', parent: 'object', site_name: 'char *', shape: 'int', position: 'vector3', diameter: 'vector3', mol: 'mcell_species', num: 'double', num_type: 'int', release_prob: 'double', rpatp: 'release_pattern', new_object: 'struct object **') -> "struct object **":
    return _pymcell.mcell_create_geometrical_release_site(state, parent, site_name, shape, position, diameter, mol, num, num_type, release_prob, rpatp, new_object)
mcell_create_geometrical_release_site = _pymcell.mcell_create_geometrical_release_site

def mcell_start_release_site(state: 'MCELL_STATE *', sym_ptr: 'mcell_symbol', obj: 'struct object **') -> "MCELL_STATUS":
    return _pymcell.mcell_start_release_site(state, sym_ptr, obj)
mcell_start_release_site = _pymcell.mcell_start_release_site

def mcell_finish_release_site(sym_ptr: 'mcell_symbol', obj: 'struct object **') -> "MCELL_STATUS":
    return _pymcell.mcell_finish_release_site(sym_ptr, obj)
mcell_finish_release_site = _pymcell.mcell_finish_release_site

def set_release_site_concentration(rel_site_obj_ptr: 'struct release_site_obj *', conc: 'double') -> "int":
    return _pymcell.set_release_site_concentration(rel_site_obj_ptr, conc)
set_release_site_concentration = _pymcell.set_release_site_concentration

def mcell_create_region_release(state: 'MCELL_STATE *', parent: 'object', release_on_in: 'object', site_name: 'char *', reg_name: 'char *', mol: 'mcell_species', num: 'double', num_type: 'int', rel_prob: 'double', rpatp: 'release_pattern', new_object: 'struct object **') -> "struct object **":
    return _pymcell.mcell_create_region_release(state, parent, release_on_in, site_name, reg_name, mol, num, num_type, rel_prob, rpatp, new_object)
mcell_create_region_release = _pymcell.mcell_create_region_release

def mcell_create_region_release_boolean(state: 'MCELL_STATE *', parent: 'object', site_name: 'char *', mol: 'mcell_species', num: 'double', num_type: 'int', rel_prob: 'double', rpatp: 'release_pattern', rel_eval: 'release_evaluator', new_object: 'struct object **') -> "struct object **":
    return _pymcell.mcell_create_region_release_boolean(state, parent, site_name, mol, num, num_type, rel_prob, rpatp, rel_eval, new_object)
mcell_create_region_release_boolean = _pymcell.mcell_create_region_release_boolean

def mcell_create_release_pattern(state: 'MCELL_STATE *', name: 'char *', delay: 'double', release_interval: 'double', train_interval: 'double', train_duration: 'double', number_of_trains: 'int') -> "struct release_pattern *":
    return _pymcell.mcell_create_release_pattern(state, name, delay, release_interval, train_interval, train_duration, number_of_trains)
mcell_create_release_pattern = _pymcell.mcell_create_release_pattern

def mcell_set_release_site_geometry_region(state: 'MCELL_STATE *', rel_site_obj_ptr: 'struct release_site_obj *', objp: 'object', re: 'release_evaluator') -> "int":
    return _pymcell.mcell_set_release_site_geometry_region(state, rel_site_obj_ptr, objp, re)
mcell_set_release_site_geometry_region = _pymcell.mcell_set_release_site_geometry_region

def check_release_regions(rel: 'release_evaluator', parent: 'object', instance: 'object') -> "int":
    return _pymcell.check_release_regions(rel, parent, instance)
check_release_regions = _pymcell.check_release_regions

def is_release_site_valid(rel_site_obj_ptr: 'struct release_site_obj *') -> "int":
    return _pymcell.is_release_site_valid(rel_site_obj_ptr)
is_release_site_valid = _pymcell.is_release_site_valid

def new_release_region_expr_term(my_sym: 'mcell_symbol') -> "struct release_evaluator *":
    return _pymcell.new_release_region_expr_term(my_sym)
new_release_region_expr_term = _pymcell.new_release_region_expr_term

def set_release_site_constant_number(rel_site_obj_ptr: 'struct release_site_obj *', num: 'double') -> "void":
    return _pymcell.set_release_site_constant_number(rel_site_obj_ptr, num)
set_release_site_constant_number = _pymcell.set_release_site_constant_number

def set_release_site_gaussian_number(rel_site_obj_ptr: 'struct release_site_obj *', mean: 'double', stdev: 'double') -> "void":
    return _pymcell.set_release_site_gaussian_number(rel_site_obj_ptr, mean, stdev)
set_release_site_gaussian_number = _pymcell.set_release_site_gaussian_number

def new_release_region_expr_binary(reL: 'release_evaluator', reR: 'release_evaluator', op: 'int') -> "struct release_evaluator *":
    return _pymcell.new_release_region_expr_binary(reL, reR, op)
new_release_region_expr_binary = _pymcell.new_release_region_expr_binary

def set_release_site_location(state: 'MCELL_STATE *', rel_site_obj_ptr: 'struct release_site_obj *', location: 'vector3') -> "void":
    return _pymcell.set_release_site_location(state, rel_site_obj_ptr, location)
set_release_site_location = _pymcell.set_release_site_location

def existing_region(state: 'MCELL_STATE *', obj_symp: 'mcell_symbol', region_name: 'char *') -> "struct sym_entry *":
    return _pymcell.existing_region(state, obj_symp, region_name)
existing_region = _pymcell.existing_region
class mcell_symbol(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mcell_symbol, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mcell_symbol, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.mcell_symbol_next_set
    __swig_getmethods__["next"] = _pymcell.mcell_symbol_next_get
    if _newclass:
        next = _swig_property(_pymcell.mcell_symbol_next_get, _pymcell.mcell_symbol_next_set)
    __swig_setmethods__["sym_type"] = _pymcell.mcell_symbol_sym_type_set
    __swig_getmethods__["sym_type"] = _pymcell.mcell_symbol_sym_type_get
    if _newclass:
        sym_type = _swig_property(_pymcell.mcell_symbol_sym_type_get, _pymcell.mcell_symbol_sym_type_set)
    __swig_setmethods__["name"] = _pymcell.mcell_symbol_name_set
    __swig_getmethods__["name"] = _pymcell.mcell_symbol_name_get
    if _newclass:
        name = _swig_property(_pymcell.mcell_symbol_name_get, _pymcell.mcell_symbol_name_set)
    __swig_setmethods__["value"] = _pymcell.mcell_symbol_value_set
    __swig_getmethods__["value"] = _pymcell.mcell_symbol_value_get
    if _newclass:
        value = _swig_property(_pymcell.mcell_symbol_value_get, _pymcell.mcell_symbol_value_set)

    def __init__(self, *args):
        """__init__(self) -> mcell_symbol"""
        this = _pymcell.new_mcell_symbol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_mcell_symbol
    __del__ = lambda self: None
mcell_symbol_swigregister = _pymcell.mcell_symbol_swigregister
mcell_symbol_swigregister(mcell_symbol)

class mcell_species_spec(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mcell_species_spec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mcell_species_spec, name)
    __repr__ = _swig_repr
    __swig_setmethods__["name"] = _pymcell.mcell_species_spec_name_set
    __swig_getmethods__["name"] = _pymcell.mcell_species_spec_name_get
    if _newclass:
        name = _swig_property(_pymcell.mcell_species_spec_name_get, _pymcell.mcell_species_spec_name_set)
    __swig_setmethods__["D"] = _pymcell.mcell_species_spec_D_set
    __swig_getmethods__["D"] = _pymcell.mcell_species_spec_D_get
    if _newclass:
        D = _swig_property(_pymcell.mcell_species_spec_D_get, _pymcell.mcell_species_spec_D_set)
    __swig_setmethods__["is_2d"] = _pymcell.mcell_species_spec_is_2d_set
    __swig_getmethods__["is_2d"] = _pymcell.mcell_species_spec_is_2d_get
    if _newclass:
        is_2d = _swig_property(_pymcell.mcell_species_spec_is_2d_get, _pymcell.mcell_species_spec_is_2d_set)
    __swig_setmethods__["custom_time_step"] = _pymcell.mcell_species_spec_custom_time_step_set
    __swig_getmethods__["custom_time_step"] = _pymcell.mcell_species_spec_custom_time_step_get
    if _newclass:
        custom_time_step = _swig_property(_pymcell.mcell_species_spec_custom_time_step_get, _pymcell.mcell_species_spec_custom_time_step_set)
    __swig_setmethods__["target_only"] = _pymcell.mcell_species_spec_target_only_set
    __swig_getmethods__["target_only"] = _pymcell.mcell_species_spec_target_only_get
    if _newclass:
        target_only = _swig_property(_pymcell.mcell_species_spec_target_only_get, _pymcell.mcell_species_spec_target_only_set)
    __swig_setmethods__["max_step_length"] = _pymcell.mcell_species_spec_max_step_length_set
    __swig_getmethods__["max_step_length"] = _pymcell.mcell_species_spec_max_step_length_get
    if _newclass:
        max_step_length = _swig_property(_pymcell.mcell_species_spec_max_step_length_get, _pymcell.mcell_species_spec_max_step_length_set)
    __swig_setmethods__["space_step"] = _pymcell.mcell_species_spec_space_step_set
    __swig_getmethods__["space_step"] = _pymcell.mcell_species_spec_space_step_get
    if _newclass:
        space_step = _swig_property(_pymcell.mcell_species_spec_space_step_get, _pymcell.mcell_species_spec_space_step_set)

    def __init__(self, *args):
        """__init__(self) -> mcell_species_spec"""
        this = _pymcell.new_mcell_species_spec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_mcell_species_spec
    __del__ = lambda self: None
mcell_species_spec_swigregister = _pymcell.mcell_species_spec_swigregister
mcell_species_spec_swigregister(mcell_species_spec)

class mcell_species(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mcell_species, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mcell_species, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.mcell_species_next_set
    __swig_getmethods__["next"] = _pymcell.mcell_species_next_get
    if _newclass:
        next = _swig_property(_pymcell.mcell_species_next_get, _pymcell.mcell_species_next_set)
    __swig_setmethods__["mol_type"] = _pymcell.mcell_species_mol_type_set
    __swig_getmethods__["mol_type"] = _pymcell.mcell_species_mol_type_get
    if _newclass:
        mol_type = _swig_property(_pymcell.mcell_species_mol_type_get, _pymcell.mcell_species_mol_type_set)
    __swig_setmethods__["orient_set"] = _pymcell.mcell_species_orient_set_set
    __swig_getmethods__["orient_set"] = _pymcell.mcell_species_orient_set_get
    if _newclass:
        orient_set = _swig_property(_pymcell.mcell_species_orient_set_get, _pymcell.mcell_species_orient_set_set)
    __swig_setmethods__["orient"] = _pymcell.mcell_species_orient_set
    __swig_getmethods__["orient"] = _pymcell.mcell_species_orient_get
    if _newclass:
        orient = _swig_property(_pymcell.mcell_species_orient_get, _pymcell.mcell_species_orient_set)

    def __init__(self, *args):
        """__init__(self) -> mcell_species"""
        this = _pymcell.new_mcell_species(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_mcell_species
    __del__ = lambda self: None
mcell_species_swigregister = _pymcell.mcell_species_swigregister
mcell_species_swigregister(mcell_species)

class mcell_species_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mcell_species_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mcell_species_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mol_type_head"] = _pymcell.mcell_species_list_mol_type_head_set
    __swig_getmethods__["mol_type_head"] = _pymcell.mcell_species_list_mol_type_head_get
    if _newclass:
        mol_type_head = _swig_property(_pymcell.mcell_species_list_mol_type_head_get, _pymcell.mcell_species_list_mol_type_head_set)
    __swig_setmethods__["mol_type_tail"] = _pymcell.mcell_species_list_mol_type_tail_set
    __swig_getmethods__["mol_type_tail"] = _pymcell.mcell_species_list_mol_type_tail_get
    if _newclass:
        mol_type_tail = _swig_property(_pymcell.mcell_species_list_mol_type_tail_get, _pymcell.mcell_species_list_mol_type_tail_set)

    def __init__(self, *args):
        """__init__(self) -> mcell_species_list"""
        this = _pymcell.new_mcell_species_list(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_mcell_species_list
    __del__ = lambda self: None
mcell_species_list_swigregister = _pymcell.mcell_species_list_swigregister
mcell_species_list_swigregister(mcell_species_list)


def mcell_create_species(state: 'MCELL_STATE *', species: 'mcell_species_spec', species_ptr: 'mcell_symbol **') -> "struct sym_entry **":
    return _pymcell.mcell_create_species(state, species, species_ptr)
mcell_create_species = _pymcell.mcell_create_species

def mcell_add_to_species_list(species_ptr: 'mcell_symbol', is_oriented: 'bool', orientation: 'int', species_list: 'mcell_species') -> "struct mcell_species *":
    return _pymcell.mcell_add_to_species_list(species_ptr, is_oriented, orientation, species_list)
mcell_add_to_species_list = _pymcell.mcell_add_to_species_list

def mcell_delete_species_list(species: 'mcell_species') -> "void":
    return _pymcell.mcell_delete_species_list(species)
mcell_delete_species_list = _pymcell.mcell_delete_species_list

def new_mol_species(state: 'MCELL_STATE *', name: 'char *', sym_ptr: 'struct sym_entry **') -> "int":
    return _pymcell.new_mol_species(state, name, sym_ptr)
new_mol_species = _pymcell.new_mol_species

def mcell_create_viz_output(state: 'MCELL_STATE *', filename: 'char *', mol_viz_list: 'mcell_species', start: 'long long', end: 'long long', step: 'long long') -> "MCELL_STATUS":
    return _pymcell.mcell_create_viz_output(state, filename, mol_viz_list, start, end, step)
mcell_create_viz_output = _pymcell.mcell_create_viz_output

def mcell_new_viz_output_block(vizblk: 'struct viz_output_block *') -> "void":
    return _pymcell.mcell_new_viz_output_block(vizblk)
mcell_new_viz_output_block = _pymcell.mcell_new_viz_output_block

def mcell_create_viz_frame(time_type: 'int', type: 'int', iteration_list: 'num_expr_list') -> "struct frame_data_list *":
    return _pymcell.mcell_create_viz_frame(time_type, type, iteration_list)
mcell_create_viz_frame = _pymcell.mcell_create_viz_frame

def mcell_set_molecule_viz_state(vizblk: 'struct viz_output_block *', specp: 'struct species *', viz_state: 'int') -> "int":
    return _pymcell.mcell_set_molecule_viz_state(vizblk, specp, viz_state)
mcell_set_molecule_viz_state = _pymcell.mcell_set_molecule_viz_state

def mcell_add_surf_class_properties(state: 'MCELL_STATE *', reaction_type: 'int', sc_sym: 'mcell_symbol', reactant_sym: 'mcell_symbol', orient: 'short') -> "MCELL_STATUS":
    return _pymcell.mcell_add_surf_class_properties(state, reaction_type, sc_sym, reactant_sym, orient)
mcell_add_surf_class_properties = _pymcell.mcell_add_surf_class_properties

def mcell_create_surf_class(state: 'MCELL_STATE *', surf_class_name: 'char *', sc_sym: 'mcell_symbol **') -> "struct sym_entry **":
    return _pymcell.mcell_create_surf_class(state, surf_class_name, sc_sym)
mcell_create_surf_class = _pymcell.mcell_create_surf_class

def mcell_add_mol_release_to_surf_class(state: 'MCELL_STATE *', sc_sym: 'mcell_symbol', sm_info: 'mcell_species', quantity: 'double', density_or_num: 'int', smd_list: 'struct sm_dat *') -> "struct sm_dat *":
    return _pymcell.mcell_add_mol_release_to_surf_class(state, sc_sym, sm_info, quantity, density_or_num, smd_list)
mcell_add_mol_release_to_surf_class = _pymcell.mcell_add_mol_release_to_surf_class

def mcell_assign_surf_class_to_region(sc_sym: 'mcell_symbol', rgn: 'struct region *') -> "MCELL_STATUS":
    return _pymcell.mcell_assign_surf_class_to_region(sc_sym, rgn)
mcell_assign_surf_class_to_region = _pymcell.mcell_assign_surf_class_to_region

def mcell_run_simulation(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_run_simulation(state)
mcell_run_simulation = _pymcell.mcell_run_simulation

def mcell_run_n_iterations(state: 'MCELL_STATE *', output_frequency: 'long long', INPUT: 'int *', n_iter: 'int') -> "MCELL_STATUS":
    return _pymcell.mcell_run_n_iterations(state, output_frequency, INPUT, n_iter)
mcell_run_n_iterations = _pymcell.mcell_run_n_iterations

def mcell_run_iteration(state: 'MCELL_STATE *', output_frequency: 'long long', INPUT: 'int *') -> "MCELL_STATUS":
    return _pymcell.mcell_run_iteration(state, output_frequency, INPUT)
mcell_run_iteration = _pymcell.mcell_run_iteration

def mcell_flush_data(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_flush_data(state)
mcell_flush_data = _pymcell.mcell_flush_data

def mcell_print_final_warnings(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_print_final_warnings(state)
mcell_print_final_warnings = _pymcell.mcell_print_final_warnings

def mcell_print_final_statistics(state: 'MCELL_STATE *') -> "MCELL_STATUS":
    return _pymcell.mcell_print_final_statistics(state)
mcell_print_final_statistics = _pymcell.mcell_print_final_statistics
ORIENT_NOT_SET = _pymcell.ORIENT_NOT_SET
class object(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, object, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, object, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.object_next_set
    __swig_getmethods__["next"] = _pymcell.object_next_get
    if _newclass:
        next = _swig_property(_pymcell.object_next_get, _pymcell.object_next_set)
    __swig_setmethods__["parent"] = _pymcell.object_parent_set
    __swig_getmethods__["parent"] = _pymcell.object_parent_get
    if _newclass:
        parent = _swig_property(_pymcell.object_parent_get, _pymcell.object_parent_set)
    __swig_setmethods__["first_child"] = _pymcell.object_first_child_set
    __swig_getmethods__["first_child"] = _pymcell.object_first_child_get
    if _newclass:
        first_child = _swig_property(_pymcell.object_first_child_get, _pymcell.object_first_child_set)
    __swig_setmethods__["last_child"] = _pymcell.object_last_child_set
    __swig_getmethods__["last_child"] = _pymcell.object_last_child_get
    if _newclass:
        last_child = _swig_property(_pymcell.object_last_child_get, _pymcell.object_last_child_set)
    __swig_setmethods__["sym"] = _pymcell.object_sym_set
    __swig_getmethods__["sym"] = _pymcell.object_sym_get
    if _newclass:
        sym = _swig_property(_pymcell.object_sym_get, _pymcell.object_sym_set)
    __swig_setmethods__["last_name"] = _pymcell.object_last_name_set
    __swig_getmethods__["last_name"] = _pymcell.object_last_name_get
    if _newclass:
        last_name = _swig_property(_pymcell.object_last_name_get, _pymcell.object_last_name_set)
    __swig_setmethods__["object_type"] = _pymcell.object_object_type_set
    __swig_getmethods__["object_type"] = _pymcell.object_object_type_get
    if _newclass:
        object_type = _swig_property(_pymcell.object_object_type_get, _pymcell.object_object_type_set)
    __swig_setmethods__["contents"] = _pymcell.object_contents_set
    __swig_getmethods__["contents"] = _pymcell.object_contents_get
    if _newclass:
        contents = _swig_property(_pymcell.object_contents_get, _pymcell.object_contents_set)
    __swig_setmethods__["num_regions"] = _pymcell.object_num_regions_set
    __swig_getmethods__["num_regions"] = _pymcell.object_num_regions_get
    if _newclass:
        num_regions = _swig_property(_pymcell.object_num_regions_get, _pymcell.object_num_regions_set)
    __swig_setmethods__["regions"] = _pymcell.object_regions_set
    __swig_getmethods__["regions"] = _pymcell.object_regions_get
    if _newclass:
        regions = _swig_property(_pymcell.object_regions_get, _pymcell.object_regions_set)
    __swig_setmethods__["n_walls"] = _pymcell.object_n_walls_set
    __swig_getmethods__["n_walls"] = _pymcell.object_n_walls_get
    if _newclass:
        n_walls = _swig_property(_pymcell.object_n_walls_get, _pymcell.object_n_walls_set)
    __swig_setmethods__["n_walls_actual"] = _pymcell.object_n_walls_actual_set
    __swig_getmethods__["n_walls_actual"] = _pymcell.object_n_walls_actual_get
    if _newclass:
        n_walls_actual = _swig_property(_pymcell.object_n_walls_actual_get, _pymcell.object_n_walls_actual_set)
    __swig_setmethods__["walls"] = _pymcell.object_walls_set
    __swig_getmethods__["walls"] = _pymcell.object_walls_get
    if _newclass:
        walls = _swig_property(_pymcell.object_walls_get, _pymcell.object_walls_set)
    __swig_setmethods__["wall_p"] = _pymcell.object_wall_p_set
    __swig_getmethods__["wall_p"] = _pymcell.object_wall_p_get
    if _newclass:
        wall_p = _swig_property(_pymcell.object_wall_p_get, _pymcell.object_wall_p_set)
    __swig_setmethods__["n_verts"] = _pymcell.object_n_verts_set
    __swig_getmethods__["n_verts"] = _pymcell.object_n_verts_get
    if _newclass:
        n_verts = _swig_property(_pymcell.object_n_verts_get, _pymcell.object_n_verts_set)
    __swig_setmethods__["vertices"] = _pymcell.object_vertices_set
    __swig_getmethods__["vertices"] = _pymcell.object_vertices_get
    if _newclass:
        vertices = _swig_property(_pymcell.object_vertices_get, _pymcell.object_vertices_set)
    __swig_setmethods__["total_area"] = _pymcell.object_total_area_set
    __swig_getmethods__["total_area"] = _pymcell.object_total_area_get
    if _newclass:
        total_area = _swig_property(_pymcell.object_total_area_get, _pymcell.object_total_area_set)
    __swig_setmethods__["n_tiles"] = _pymcell.object_n_tiles_set
    __swig_getmethods__["n_tiles"] = _pymcell.object_n_tiles_get
    if _newclass:
        n_tiles = _swig_property(_pymcell.object_n_tiles_get, _pymcell.object_n_tiles_set)
    __swig_setmethods__["n_occupied_tiles"] = _pymcell.object_n_occupied_tiles_set
    __swig_getmethods__["n_occupied_tiles"] = _pymcell.object_n_occupied_tiles_get
    if _newclass:
        n_occupied_tiles = _swig_property(_pymcell.object_n_occupied_tiles_get, _pymcell.object_n_occupied_tiles_set)
    __swig_setmethods__["t_matrix"] = _pymcell.object_t_matrix_set
    __swig_getmethods__["t_matrix"] = _pymcell.object_t_matrix_get
    if _newclass:
        t_matrix = _swig_property(_pymcell.object_t_matrix_get, _pymcell.object_t_matrix_set)
    __swig_setmethods__["periodic_x"] = _pymcell.object_periodic_x_set
    __swig_getmethods__["periodic_x"] = _pymcell.object_periodic_x_get
    if _newclass:
        periodic_x = _swig_property(_pymcell.object_periodic_x_get, _pymcell.object_periodic_x_set)
    __swig_setmethods__["periodic_y"] = _pymcell.object_periodic_y_set
    __swig_getmethods__["periodic_y"] = _pymcell.object_periodic_y_get
    if _newclass:
        periodic_y = _swig_property(_pymcell.object_periodic_y_get, _pymcell.object_periodic_y_set)
    __swig_setmethods__["periodic_z"] = _pymcell.object_periodic_z_set
    __swig_getmethods__["periodic_z"] = _pymcell.object_periodic_z_get
    if _newclass:
        periodic_z = _swig_property(_pymcell.object_periodic_z_get, _pymcell.object_periodic_z_set)

    def __init__(self, *args):
        """__init__(self) -> object"""
        this = _pymcell.new_object(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_object
    __del__ = lambda self: None
object_swigregister = _pymcell.object_swigregister
object_swigregister(object)

SHAPE_UNDEFINED = _pymcell.SHAPE_UNDEFINED
SHAPE_SPHERICAL = _pymcell.SHAPE_SPHERICAL
SHAPE_CUBIC = _pymcell.SHAPE_CUBIC
SHAPE_ELLIPTIC = _pymcell.SHAPE_ELLIPTIC
SHAPE_RECTANGULAR = _pymcell.SHAPE_RECTANGULAR
SHAPE_SPHERICAL_SHELL = _pymcell.SHAPE_SPHERICAL_SHELL
SHAPE_REGION = _pymcell.SHAPE_REGION
SHAPE_LIST = _pymcell.SHAPE_LIST
NOTIFY_NONE = _pymcell.NOTIFY_NONE
NOTIFY_BRIEF = _pymcell.NOTIFY_BRIEF
NOTIFY_FULL = _pymcell.NOTIFY_FULL
WARN_COPE = _pymcell.WARN_COPE
WARN_WARN = _pymcell.WARN_WARN
WARN_ERROR = _pymcell.WARN_ERROR
FILE_UNDEFINED = _pymcell.FILE_UNDEFINED
FILE_OVERWRITE = _pymcell.FILE_OVERWRITE
FILE_SUBSTITUTE = _pymcell.FILE_SUBSTITUTE
FILE_APPEND = _pymcell.FILE_APPEND
FILE_APPEND_HEADER = _pymcell.FILE_APPEND_HEADER
FILE_CREATE = _pymcell.FILE_CREATE
REPORT_CONTENTS = _pymcell.REPORT_CONTENTS
REPORT_WORLD = _pymcell.REPORT_WORLD
REPORT_ENCLOSED = _pymcell.REPORT_ENCLOSED
REPORT_TRIGGER = _pymcell.REPORT_TRIGGER
class release_pattern(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, release_pattern, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, release_pattern, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sym"] = _pymcell.release_pattern_sym_set
    __swig_getmethods__["sym"] = _pymcell.release_pattern_sym_get
    if _newclass:
        sym = _swig_property(_pymcell.release_pattern_sym_get, _pymcell.release_pattern_sym_set)
    __swig_setmethods__["delay"] = _pymcell.release_pattern_delay_set
    __swig_getmethods__["delay"] = _pymcell.release_pattern_delay_get
    if _newclass:
        delay = _swig_property(_pymcell.release_pattern_delay_get, _pymcell.release_pattern_delay_set)
    __swig_setmethods__["release_interval"] = _pymcell.release_pattern_release_interval_set
    __swig_getmethods__["release_interval"] = _pymcell.release_pattern_release_interval_get
    if _newclass:
        release_interval = _swig_property(_pymcell.release_pattern_release_interval_get, _pymcell.release_pattern_release_interval_set)
    __swig_setmethods__["train_interval"] = _pymcell.release_pattern_train_interval_set
    __swig_getmethods__["train_interval"] = _pymcell.release_pattern_train_interval_get
    if _newclass:
        train_interval = _swig_property(_pymcell.release_pattern_train_interval_get, _pymcell.release_pattern_train_interval_set)
    __swig_setmethods__["train_duration"] = _pymcell.release_pattern_train_duration_set
    __swig_getmethods__["train_duration"] = _pymcell.release_pattern_train_duration_get
    if _newclass:
        train_duration = _swig_property(_pymcell.release_pattern_train_duration_get, _pymcell.release_pattern_train_duration_set)
    __swig_setmethods__["number_of_trains"] = _pymcell.release_pattern_number_of_trains_set
    __swig_getmethods__["number_of_trains"] = _pymcell.release_pattern_number_of_trains_get
    if _newclass:
        number_of_trains = _swig_property(_pymcell.release_pattern_number_of_trains_get, _pymcell.release_pattern_number_of_trains_set)

    def __init__(self, *args):
        """__init__(self) -> release_pattern"""
        this = _pymcell.new_release_pattern(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_release_pattern
    __del__ = lambda self: None
release_pattern_swigregister = _pymcell.release_pattern_swigregister
release_pattern_swigregister(release_pattern)

class release_evaluator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, release_evaluator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, release_evaluator, name)
    __repr__ = _swig_repr
    __swig_setmethods__["op"] = _pymcell.release_evaluator_op_set
    __swig_getmethods__["op"] = _pymcell.release_evaluator_op_get
    if _newclass:
        op = _swig_property(_pymcell.release_evaluator_op_get, _pymcell.release_evaluator_op_set)
    __swig_setmethods__["left"] = _pymcell.release_evaluator_left_set
    __swig_getmethods__["left"] = _pymcell.release_evaluator_left_get
    if _newclass:
        left = _swig_property(_pymcell.release_evaluator_left_get, _pymcell.release_evaluator_left_set)
    __swig_setmethods__["right"] = _pymcell.release_evaluator_right_set
    __swig_getmethods__["right"] = _pymcell.release_evaluator_right_get
    if _newclass:
        right = _swig_property(_pymcell.release_evaluator_right_get, _pymcell.release_evaluator_right_set)

    def __init__(self, *args):
        """__init__(self) -> release_evaluator"""
        this = _pymcell.new_release_evaluator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_release_evaluator
    __del__ = lambda self: None
release_evaluator_swigregister = _pymcell.release_evaluator_swigregister
release_evaluator_swigregister(release_evaluator)

class output_set(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, output_set, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, output_set, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.output_set_next_set
    __swig_getmethods__["next"] = _pymcell.output_set_next_get
    if _newclass:
        next = _swig_property(_pymcell.output_set_next_get, _pymcell.output_set_next_set)
    __swig_setmethods__["block"] = _pymcell.output_set_block_set
    __swig_getmethods__["block"] = _pymcell.output_set_block_get
    if _newclass:
        block = _swig_property(_pymcell.output_set_block_get, _pymcell.output_set_block_set)
    __swig_setmethods__["outfile_name"] = _pymcell.output_set_outfile_name_set
    __swig_getmethods__["outfile_name"] = _pymcell.output_set_outfile_name_get
    if _newclass:
        outfile_name = _swig_property(_pymcell.output_set_outfile_name_get, _pymcell.output_set_outfile_name_set)
    __swig_setmethods__["file_flags"] = _pymcell.output_set_file_flags_set
    __swig_getmethods__["file_flags"] = _pymcell.output_set_file_flags_get
    if _newclass:
        file_flags = _swig_property(_pymcell.output_set_file_flags_get, _pymcell.output_set_file_flags_set)
    __swig_setmethods__["chunk_count"] = _pymcell.output_set_chunk_count_set
    __swig_getmethods__["chunk_count"] = _pymcell.output_set_chunk_count_get
    if _newclass:
        chunk_count = _swig_property(_pymcell.output_set_chunk_count_get, _pymcell.output_set_chunk_count_set)
    __swig_setmethods__["header_comment"] = _pymcell.output_set_header_comment_set
    __swig_getmethods__["header_comment"] = _pymcell.output_set_header_comment_get
    if _newclass:
        header_comment = _swig_property(_pymcell.output_set_header_comment_get, _pymcell.output_set_header_comment_set)
    __swig_setmethods__["exact_time_flag"] = _pymcell.output_set_exact_time_flag_set
    __swig_getmethods__["exact_time_flag"] = _pymcell.output_set_exact_time_flag_get
    if _newclass:
        exact_time_flag = _swig_property(_pymcell.output_set_exact_time_flag_get, _pymcell.output_set_exact_time_flag_set)
    __swig_setmethods__["column_head"] = _pymcell.output_set_column_head_set
    __swig_getmethods__["column_head"] = _pymcell.output_set_column_head_get
    if _newclass:
        column_head = _swig_property(_pymcell.output_set_column_head_get, _pymcell.output_set_column_head_set)

    def __init__(self, *args):
        """__init__(self) -> output_set"""
        this = _pymcell.new_output_set(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_output_set
    __del__ = lambda self: None
output_set_swigregister = _pymcell.output_set_swigregister
output_set_swigregister(output_set)

OUTPUT_BY_STEP = _pymcell.OUTPUT_BY_STEP
OUTPUT_BY_TIME_LIST = _pymcell.OUTPUT_BY_TIME_LIST
OUTPUT_BY_ITERATION_LIST = _pymcell.OUTPUT_BY_ITERATION_LIST
class sym_table_head(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sym_table_head, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sym_table_head, name)
    __repr__ = _swig_repr
    __swig_setmethods__["entries"] = _pymcell.sym_table_head_entries_set
    __swig_getmethods__["entries"] = _pymcell.sym_table_head_entries_get
    if _newclass:
        entries = _swig_property(_pymcell.sym_table_head_entries_get, _pymcell.sym_table_head_entries_set)
    __swig_setmethods__["n_entries"] = _pymcell.sym_table_head_n_entries_set
    __swig_getmethods__["n_entries"] = _pymcell.sym_table_head_n_entries_get
    if _newclass:
        n_entries = _swig_property(_pymcell.sym_table_head_n_entries_get, _pymcell.sym_table_head_n_entries_set)
    __swig_setmethods__["n_bins"] = _pymcell.sym_table_head_n_bins_set
    __swig_getmethods__["n_bins"] = _pymcell.sym_table_head_n_bins_get
    if _newclass:
        n_bins = _swig_property(_pymcell.sym_table_head_n_bins_get, _pymcell.sym_table_head_n_bins_set)

    def __init__(self, *args):
        """__init__(self) -> sym_table_head"""
        this = _pymcell.new_sym_table_head(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_sym_table_head
    __del__ = lambda self: None
sym_table_head_swigregister = _pymcell.sym_table_head_swigregister
sym_table_head_swigregister(sym_table_head)

class sym_entry(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sym_entry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sym_entry, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.sym_entry_next_set
    __swig_getmethods__["next"] = _pymcell.sym_entry_next_get
    if _newclass:
        next = _swig_property(_pymcell.sym_entry_next_get, _pymcell.sym_entry_next_set)
    __swig_setmethods__["sym_type"] = _pymcell.sym_entry_sym_type_set
    __swig_getmethods__["sym_type"] = _pymcell.sym_entry_sym_type_get
    if _newclass:
        sym_type = _swig_property(_pymcell.sym_entry_sym_type_get, _pymcell.sym_entry_sym_type_set)
    __swig_setmethods__["name"] = _pymcell.sym_entry_name_set
    __swig_getmethods__["name"] = _pymcell.sym_entry_name_get
    if _newclass:
        name = _swig_property(_pymcell.sym_entry_name_get, _pymcell.sym_entry_name_set)
    __swig_setmethods__["value"] = _pymcell.sym_entry_value_set
    __swig_getmethods__["value"] = _pymcell.sym_entry_value_get
    if _newclass:
        value = _swig_property(_pymcell.sym_entry_value_get, _pymcell.sym_entry_value_set)

    def __init__(self, *args):
        """__init__(self) -> sym_entry"""
        this = _pymcell.new_sym_entry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_sym_entry
    __del__ = lambda self: None
sym_entry_swigregister = _pymcell.sym_entry_swigregister
sym_entry_swigregister(sym_entry)

class sym_table_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sym_table_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sym_table_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.sym_table_list_next_set
    __swig_getmethods__["next"] = _pymcell.sym_table_list_next_get
    if _newclass:
        next = _swig_property(_pymcell.sym_table_list_next_get, _pymcell.sym_table_list_next_set)
    __swig_setmethods__["node"] = _pymcell.sym_table_list_node_set
    __swig_getmethods__["node"] = _pymcell.sym_table_list_node_get
    if _newclass:
        node = _swig_property(_pymcell.sym_table_list_node_get, _pymcell.sym_table_list_node_set)

    def __init__(self, *args):
        """__init__(self) -> sym_table_list"""
        this = _pymcell.new_sym_table_list(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_sym_table_list
    __del__ = lambda self: None
sym_table_list_swigregister = _pymcell.sym_table_list_swigregister
sym_table_list_swigregister(sym_table_list)

class num_expr_list(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, num_expr_list, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, num_expr_list, name)
    __repr__ = _swig_repr
    __swig_setmethods__["next"] = _pymcell.num_expr_list_next_set
    __swig_getmethods__["next"] = _pymcell.num_expr_list_next_get
    if _newclass:
        next = _swig_property(_pymcell.num_expr_list_next_get, _pymcell.num_expr_list_next_set)
    __swig_setmethods__["value"] = _pymcell.num_expr_list_value_set
    __swig_getmethods__["value"] = _pymcell.num_expr_list_value_get
    if _newclass:
        value = _swig_property(_pymcell.num_expr_list_value_get, _pymcell.num_expr_list_value_set)

    def __init__(self, *args):
        """__init__(self) -> num_expr_list"""
        this = _pymcell.new_num_expr_list(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_num_expr_list
    __del__ = lambda self: None
num_expr_list_swigregister = _pymcell.num_expr_list_swigregister
num_expr_list_swigregister(num_expr_list)

class mesh_region_string_buffs(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mesh_region_string_buffs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mesh_region_string_buffs, name)
    __repr__ = _swig_repr
    __swig_setmethods__["old_inst_mesh_names"] = _pymcell.mesh_region_string_buffs_old_inst_mesh_names_set
    __swig_getmethods__["old_inst_mesh_names"] = _pymcell.mesh_region_string_buffs_old_inst_mesh_names_get
    if _newclass:
        old_inst_mesh_names = _swig_property(_pymcell.mesh_region_string_buffs_old_inst_mesh_names_get, _pymcell.mesh_region_string_buffs_old_inst_mesh_names_set)
    __swig_setmethods__["old_region_names"] = _pymcell.mesh_region_string_buffs_old_region_names_set
    __swig_getmethods__["old_region_names"] = _pymcell.mesh_region_string_buffs_old_region_names_get
    if _newclass:
        old_region_names = _swig_property(_pymcell.mesh_region_string_buffs_old_region_names_get, _pymcell.mesh_region_string_buffs_old_region_names_set)

    def __init__(self, *args):
        """__init__(self) -> mesh_region_string_buffs"""
        this = _pymcell.new_mesh_region_string_buffs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_mesh_region_string_buffs
    __del__ = lambda self: None
mesh_region_string_buffs_swigregister = _pymcell.mesh_region_string_buffs_swigregister
mesh_region_string_buffs_swigregister(mesh_region_string_buffs)


def mcell_change_geometry(state: 'struct volume *', pobj_list: 'poly_object_list') -> "int":
    return _pymcell.mcell_change_geometry(state, pobj_list)
mcell_change_geometry = _pymcell.mcell_change_geometry
class vector2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector2, name)
    __repr__ = _swig_repr
    __swig_setmethods__["u"] = _pymcell.vector2_u_set
    __swig_getmethods__["u"] = _pymcell.vector2_u_get
    if _newclass:
        u = _swig_property(_pymcell.vector2_u_get, _pymcell.vector2_u_set)
    __swig_setmethods__["v"] = _pymcell.vector2_v_set
    __swig_getmethods__["v"] = _pymcell.vector2_v_get
    if _newclass:
        v = _swig_property(_pymcell.vector2_v_get, _pymcell.vector2_v_set)

    def __init__(self, *args):
        """__init__(self) -> vector2"""
        this = _pymcell.new_vector2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_vector2
    __del__ = lambda self: None
vector2_swigregister = _pymcell.vector2_swigregister
vector2_swigregister(vector2)

class vector3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector3, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _pymcell.vector3_x_set
    __swig_getmethods__["x"] = _pymcell.vector3_x_get
    if _newclass:
        x = _swig_property(_pymcell.vector3_x_get, _pymcell.vector3_x_set)
    __swig_setmethods__["y"] = _pymcell.vector3_y_set
    __swig_getmethods__["y"] = _pymcell.vector3_y_get
    if _newclass:
        y = _swig_property(_pymcell.vector3_y_get, _pymcell.vector3_y_set)
    __swig_setmethods__["z"] = _pymcell.vector3_z_set
    __swig_getmethods__["z"] = _pymcell.vector3_z_get
    if _newclass:
        z = _swig_property(_pymcell.vector3_z_get, _pymcell.vector3_z_set)

    def __init__(self, *args):
        """__init__(self) -> vector3"""
        this = _pymcell.new_vector3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _pymcell.delete_vector3
    __del__ = lambda self: None
vector3_swigregister = _pymcell.vector3_swigregister
vector3_swigregister(vector3)


def mult_matrix(m1: 'double (*)[4]', m2: 'double (*)[4]', om: 'double (*)[4]', l: 'unsigned short', m: 'unsigned short', n: 'unsigned short') -> "void":
    return _pymcell.mult_matrix(m1, m2, om, l, m, n)
mult_matrix = _pymcell.mult_matrix

def normalize(v: 'vector3') -> "void":
    return _pymcell.normalize(v)
normalize = _pymcell.normalize

def init_matrix(im: 'double (*)[4]') -> "void":
    return _pymcell.init_matrix(im)
init_matrix = _pymcell.init_matrix

def scale_matrix(im: 'double (*)[4]', om: 'double (*)[4]', scale: 'vector3') -> "void":
    return _pymcell.scale_matrix(im, om, scale)
scale_matrix = _pymcell.scale_matrix

def translate_matrix(im: 'double (*)[4]', om: 'double (*)[4]', translate: 'vector3') -> "void":
    return _pymcell.translate_matrix(im, om, translate)
translate_matrix = _pymcell.translate_matrix

def rotate_matrix(im: 'double (*)[4]', om: 'double (*)[4]', axis: 'vector3', angle: 'double') -> "void":
    return _pymcell.rotate_matrix(im, om, axis, angle)
rotate_matrix = _pymcell.rotate_matrix

def tform_matrix(scale: 'vector3', translate: 'vector3', axis: 'vector3', angle: 'double', om: 'double (*)[4]') -> "void":
    return _pymcell.tform_matrix(scale, translate, axis, angle, om)
tform_matrix = _pymcell.tform_matrix

def vectorize(p1: 'vector3', p2: 'vector3', v: 'vector3') -> "void":
    return _pymcell.vectorize(p1, p2, v)
vectorize = _pymcell.vectorize

def vect_length(v: 'vector3') -> "double":
    return _pymcell.vect_length(v)
vect_length = _pymcell.vect_length

def dot_prod(v1: 'vector3', v2: 'vector3') -> "double":
    return _pymcell.dot_prod(v1, v2)
dot_prod = _pymcell.dot_prod

def cross_prod(v1: 'vector3', v2: 'vector3', v3: 'vector3') -> "void":
    return _pymcell.cross_prod(v1, v2, v3)
cross_prod = _pymcell.cross_prod

def vect_sum(v1: 'vector3', v2: 'vector3', v3: 'vector3') -> "void":
    return _pymcell.vect_sum(v1, v2, v3)
vect_sum = _pymcell.vect_sum

def scalar_prod(v1: 'vector3', a: 'double', result: 'vector3') -> "void":
    return _pymcell.scalar_prod(v1, a, result)
scalar_prod = _pymcell.scalar_prod

def distinguishable_vec3(a: 'vector3', b: 'vector3', eps: 'double') -> "int":
    return _pymcell.distinguishable_vec3(a, b, eps)
distinguishable_vec3 = _pymcell.distinguishable_vec3

def distinguishable_vec2(a: 'vector2', b: 'vector2', eps: 'double') -> "int":
    return _pymcell.distinguishable_vec2(a, b, eps)
distinguishable_vec2 = _pymcell.distinguishable_vec2

def distance_vec3(a: 'vector3', b: 'vector3') -> "double":
    return _pymcell.distance_vec3(a, b)
distance_vec3 = _pymcell.distance_vec3

def parallel_segments(A: 'vector3', B: 'vector3', R: 'vector3', S: 'vector3') -> "int":
    return _pymcell.parallel_segments(A, B, R, S)
parallel_segments = _pymcell.parallel_segments

def point_in_triangle(p: 'vector3', a: 'vector3', b: 'vector3', c: 'vector3') -> "int":
    return _pymcell.point_in_triangle(p, a, b, c)
point_in_triangle = _pymcell.point_in_triangle

def same_side(p1: 'vector3', p2: 'vector3', a: 'vector3', b: 'vector3') -> "int":
    return _pymcell.same_side(p1, p2, a, b)
same_side = _pymcell.same_side

def intersect_point_segment(P: 'vector3', A: 'vector3', B: 'vector3') -> "int":
    return _pymcell.intersect_point_segment(P, A, B)
intersect_point_segment = _pymcell.intersect_point_segment

def cross2D(a: 'vector2', b: 'vector2') -> "double":
    return _pymcell.cross2D(a, b)
cross2D = _pymcell.cross2D

def vectorize2D(p1: 'vector2', p2: 'vector2', p3: 'vector2') -> "void":
    return _pymcell.vectorize2D(p1, p2, p3)
vectorize2D = _pymcell.vectorize2D

def point_in_triangle_2D(p: 'vector2', a: 'vector2', b: 'vector2', c: 'vector2') -> "int":
    return _pymcell.point_in_triangle_2D(p, a, b, c)
point_in_triangle_2D = _pymcell.point_in_triangle_2D

def point_in_box(low_left: 'vector3', up_right: 'vector3', point: 'vector3') -> "int":
    return _pymcell.point_in_box(low_left, up_right, point)
point_in_box = _pymcell.point_in_box
# This file is compatible with both classic and new-style classes.


